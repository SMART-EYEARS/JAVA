# 들어가면서  
> **목표 :** 자바의 예외 처리에 대해 학습하세요.     
      
[1. 프로그램의 에러](#프로그램의-에러)    
[2. Exception과 Error의 차이](#exception과-error의-차이)        
[3. 자바가 제공하는 예외 계층 구조](#자바가-제공하는-예외-계층-구조)            
[4. RuntimeException과 Exception](#runtimeexception과-exception)       
[5. 자바에서 예외 처리 방법](#자바에서-예외-처리-방법)            
[6. 커스텀한 예외 만드는 방법](#커스텀한-예외-만드는-방법)      
         
 추가할 내용들    
 더블 캐치 (위에서 거르면 아래에서 컴파일 에러 발생)     
 각 익셉션들     
 클린코드에서 지향하는 예외 설정   
    
# 프로그램의 에러   
프로그램이 실행 중 어떤 원인에 의해서 오작동하거나 비정삭적으로 종료되는 경우가 있다.   
이러한 결과를 초래하는 원인을 프로그램 **에러** 또는 **오류**라고 말한다.      
           
에러는 대표적으로 3가지로 나눌 수 있다.    
        
1. **컴파일 에러 :** 컴파일 시에 발생하는 에러      
2. **런타임 에러 :** 런타임 시에 발생하는 에러       
3. **논리적 에러 :** 실행은 되지만, 의도와 다르게 동작하는 것        

이 외에도 **우리가 아직 발견하지 못한 에러가 존재할 수도 있다.**       
        
프로그램을 개발하고 실행하는 과정 전반에 걸쳐 우리는 무수히 많은 에러를 접할 수 밖에 없다.             
**'에러가 없는 `100%` 완벽한 프로그램은 없다.'** 라는 말이 있다.         
우리는 **프로그램에서 발생할 수 있는 에러의 경우의 수를 고려하여 이에 대한 대비를 해야한다.**         
      
# Exception과 Error의 차이                 
자바에서는 런타임에 발생할 수 있는 오류를 **에러**와 **예외**로 구분한다.                
              
**에러**                 
<img width="1398" alt="스크린샷 2021-01-13 오후 10 41 20" src="https://user-images.githubusercontent.com/50267433/104459801-98436e00-55f0-11eb-8626-9b633b97f0f9.png">   

     
```java
public class ForError {
    public static void main(String[] args) {
        recursion();
    }
    public static void recursion(){
        System.out.println(111111);
        recursion();
    }
}
```
메모리 부족이나, 스택오버플로우와 같이 발생하면 복구할 수 없는 심각한 오류로,          
코드로 수습할 수 없어 프로그램의 비정상적인 종료를 막을 수 없다.          
프로그래머의 잘못된 코드로 인해 발생하는 경우가 대부분이지만, 간혹 HW 문제로 발생하기도 한다.   
         
**예외**     
<img width="1399" alt="스크린샷 2021-01-14 오후 8 45 16" src="https://user-images.githubusercontent.com/50267433/104586895-75c15b80-56a9-11eb-8f67-e27da9be0d5b.png">  

       
```java
package study;


public class ForException {
    private static String returnString() {
        return null;
    }

    public static void main(String[] args) {
        String getSentence = returnString();
        if(getSentence.equals("Hello World!")){
            System.out.println(getSentence);
        }
    }
}
```
정상적이지 않은 상황을 의미하며, 발생하더라도 수습될 수 있는 비교적 덜 심각한 오류로,                   
예외에 대한 적절한 코드를 미리 작성해 놓으면 프로그램의 비정상적인 종료를 막을 수 있다.              
단, 예외 또한 프로그램에 있어 충분히 위험하고 **발생시키지 않도록 노력하는 것이 중요하다.**            
   
# 자바가 제공하는 예외 계층 구조       
<img width="723" alt="스크린샷 2021-01-14 오후 8 52 26" src="https://user-images.githubusercontent.com/50267433/104587580-70184580-56aa-11eb-847d-624eb03e65cd.png">  

     
출처 : https://examples.javacodegeeks.com/java-throw-exception-example/                
`너무나 완벽한 이미지여서 참고했고 IllegalArgumentException를 추가했다.`      
    
자바에서는 실행 시 발생할 수 있는 오류(Exception/Error)를 클래스로 정의했다.   
모든 오류 클래스는 조상으로 `Throwable` 클래스를 가지고 있다.      
예외 처리시 자주 사용되는 `printStackTrace()`메서드도 `Throwable` 클래스 안에 있다.     

# RuntimeException과 Exception       
    
<img width="723" alt="스크린샷 2021-01-14 오후 9 36 16" src="https://user-images.githubusercontent.com/50267433/104591802-904b0300-56b0-11eb-83d4-b68b8e7ef16a.png">

     
Exception(예외) 클래스들은 크게 2분류로 나뉜다.       
    
1. **RuntimeException 클래스 :** RuntimeException 클래스와 자손들           
2. **Exception 클래스 :** RuntimeException을 제외한 Exception 클래스와 자손들
    
**RuntimeException 클래스**   
* RuntimeException 클래스들은 주로 프로그래머의 실수에 의해 발생될 수 있는 예외들이다.      
* 주로 자바 프로그래밍 요소들과 관계가 깊다.          
  * ArrayIndexOutOfBoundsException
  * NullPointerException
  * ClassCastException
  * ArithmeticException
  * 기타 등등
    
**Exception 클래스**     
* Exception 클래스들은 주로 외부의 영향으로 발생할 수 있는 예외들이다.            
* 프로그램의 사용자들의 동작에 의해서 발생하는 경우가 많다.         
  * FileNotFoundException    
  * ClassNotFoundException     
  * DataFormatException     

이런 `RuntimeException`/`Exception` 클래스는 프로그래밍 방법에서도 차이를 보인다.          
`Exception 클래스`들은 `Checked Exception`으로 무조건 예외처리를 해줘야한다.       
`RuntimeException 클래스`들은 `Unchecked Exception`으로 예외처리를 생략해도 된다.   
     
||Checked Exception|Unchecked Exception|   
|-|-----------------|-------------------|       
|처리 여부|반드시 예외를 처리해야 함|명시적인 처리를 강제하지 않음|  
|확인 시점|컴파일 단계|실행 단계|    
|예외 발생시 트랜잭션 처리|Roll-back 하지 않음|Roll-back 함|   
|대표 예외|**Exception의 상속받는 하위 클래스 중**<br> **Runtime Exception을 제외한 모든 예외**<br> * IOException<br>* SQLException|**Runtime Exception 하위 예외**<br>* NullPointerException<br>* IllegalArgumentException<br>* IndexOutOfBoundException<br>* SystemException|  
    
# 자바에서 예외 처리 방법    
**예외 처리 :**                   
프로그램 실행 시 발생할 수 있는 '예외'의 발생에 대비한 코드를 작성하는 것으로                         
실행 중인 프로그램의 갑작스런 비정상 종료를 막고, 실행 상태를 유지할 수 있도록 해준다.        
     
발생한 예외를 처리하지 못하면 프로그램은 비정상적으로 종료되며,         
처리되지 못한 예외는 JVM의 예외처리기가 받아서 예외의 원인을 화면에 출력한다.        
   
## try ~ catch     
예외를 처리하는 방식으로 `try-catch 문`이 있다.     
      
```java
try {
    ... 관찰 영역...   
}
catch(Exception name) {
    ... 처리 영역...  
}     
```
```java
public class ExceptionStudy {
    public static void main(String[] args) {
        Scanner kb = new Scanner(System.in);

        try {
            System.out.print("a/b...a? ");
            int n1 = kb.nextInt();
            System.out.print("a/b...b? ");
            int n2 = kb.nextInt();
            System.out.printf("%d / %d = %d \n", n1, n2, n1 / n2);    // 예외 발생 지점
        } catch (ArithmeticException e) {
            System.out.println(e.getMessage());
        }

        System.out.println("Good bye~~!");
    }
}
// 참고로 정수를 0으로 나누는 것은 예외가 발생하지만,    
// 실수를 0으로 나누는 것은 예외가 발생하지 않는다.    

/* 실행 결과
 / by zero
 Good bye~~!
 */
```     
`try 영역`에서 발생한 얘외 상황을 `catch 영역`에서 처리한다.        
                         
`try 영역`의 실행 중간에 예외 상황이 발생하면 JVM은 예외에 알맞은 '예외 객체'를 생성한다.                               
'예외 객체'는 `catch 구문`의 매개변수에 전달되면서 `catch 구문`안에서 예외 처리를 진행한다.             
참고로, `catch 구문`이 수행되면 내부 로직은 상관없이 JVM에서는 예외 처리가 된 것으로 간주한다.        
          
**try-catch문 흐름**         
`try-catch 문`에서는, 예외가 발생한 경우와 발생하지 않았을 때의 흐름이 달라진다.   
   
* **try블럭 내에서 예외가 발생하지 않은 경우**      
  * `catch 블럭`을 거치지 않고 전체 `try-catch문`을 빠져나가서 수행을 계속한다.    
<img width="723" alt="스크린샷 2021-01-15 오후 12 30 23" src="https://user-images.githubusercontent.com/50267433/104677831-7a2f5800-572d-11eb-906c-8055effbde0a.png">  
   
     
* **try블럭 내에서 예외가 발생한 경우**      
  * 발생한 예외와 일치하는 `catch 문`이 있는지 확인한다.
  * 일치하는 `catch 문`을 찾게되면, 그 `catch 문`을 실행하고 프로그램 실행을 계속한다.         
  * 일치하는 `catch 문`이 없다면 예외 처리가 되지 않아 프로그램이 종료된다.        
    
<img width="723" alt="스크린샷 2021-01-15 오후 12 28 00" src="https://user-images.githubusercontent.com/50267433/104677759-5704a880-572d-11eb-901f-5353654240c6.png">  
              
`try 문` 내에서 예외가 발생하면 `catch 문`으로 '실행 흐름'이 바뀐다.            
그렇기에 예외가 발생한 코드보다 아래에 존재하는 다른 코드들은 실행이 되지 않는다.       
         
그렇다면 우리는 중요한 국면에 처한다.      
try의 범위를 어디까지로 설정을 해야하는 것인가?   
       
       
       
**catch 문의 괄호`()`**      
```java
public class ExceptionStudy {
    public static void main(String[] args) {
        Scanner kb = new Scanner(System.in);

        try {
            System.out.print("a/b...a? ");
            int n1 = kb.nextInt();
            System.out.print("a/b...b? ");
            int n2 = kb.nextInt();
            System.out.printf("%d / %d = %d \n", n1, n2, n1 / n2);    // 예외 발생 지점
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }

        System.out.println("Good bye~~!");
    }
}
```
`catch 문`의 괄호`()`에는 예외클래스 타입과 참조변수를 기술한다.                
`catch 문`의 괄호`()`는 메서드의 매개변수와 마찬가지로 하위 예외 객체를 인자로 받을 수 있다.          
그렇기에 `Exception` 클래스 타입의 참조변수를 지정하면 모든 예외를 처리할 수 있다.            
하지만, 이는 단순히 로직만 돌아가는 것일 뿐이지 코드만 보면 어떤 에러가 발생하는지 알기 어려워진다.           

```java
public class ExceptionStudy {
    public static void main(String[] args) {
        Scanner kb = new Scanner(System.in);

        try {
            System.out.print("a/b...a? ");
            int n1 = kb.nextInt();
            System.out.print("a/b...b? ");
            int n2 = kb.nextInt();
            System.out.printf("%d / %d = %d \n", n1, n2, n1 / n2);    // 예외 발생 지점
        } catch (ArithmeticException e) {
            System.out.println(e.getMessage());
        }

        System.out.println("Good bye~~!");
    }
}
```
코드는 명확해야한다.    
프로그램을 실행시키지 않아도 어떤 로직이 수행되는지 동료와 함께 파악할 수 있어야한다.      
그렇기에 명확한 예외클래스를 정의하는 습관을 가지도록 노력하자.    
    
**다중 catch 문**        
```java
public class ExceptionStudy {
    public static void main(String[] args) {
        Scanner kb = new Scanner(System.in);

        try {
            System.out.print("a/b...a? ");
            int n1 = kb.nextInt();
            System.out.print("a/b...b? ");
            int n2 = kb.nextInt();
            System.out.printf("%d / %d = %d \n", n1, n2, n1 / n2);    // 예외 발생 지점
        } catch (ArithmeticException e) {
            System.out.println(e.getMessage());
        }

        System.out.println("Good bye~~!");
    }
}
```
이전부터 계속 제시되었던 이 코드는 사실 2가지 에러를 발생시킬 수 있다.   
        
1. ArithmeticException        
2. InputMismatchException     
        
JDK 7부터 하나의 `try 문`에 여러 `catch 문`을 사용할 수 있게 되었다.           
그렇기 때문에 위와 같은 코드도 `다중 catch 문`을 이용해서 한 번에 처리할 수 있다.   

```java
public class ExceptionStudy {
    public static void main(String[] args) {
        Scanner kb = new Scanner(System.in);

        try {
            System.out.print("a/b...a? ");
            int n1 = kb.nextInt();
            System.out.print("a/b...b? ");
            int n2 = kb.nextInt();
            System.out.printf("%d / %d = %d \n", n1, n2, n1 / n2);    // 예외 발생 지점
        } catch (ArithmeticException e) {
            System.out.println(e.getMessage());
        } catch (InputMismatchException e) {
            System.out.println(e.getMessage());
        }

        System.out.println("Good bye~~!");
    }
}
```
* `catch 문`을 한번 더 사용해서 처리를 해주었다.        
        
만약에 처리해야할 예외 클래스 많다면 어떻게 될까?             
사실 그런 경우 클래스의 설계가 잘못된 것이지만, 이를 생략하고 따져보겠다.         
모든 `catch 문`을 사용해줘야 할까? **맞다.**      
하지만, 이를 조금 줄일 수 있는 방법이 있다.      

```java
public class ExceptionStudy {
    public static void main(String[] args) {
       Scanner kb = new Scanner(System.in);
   
       try {
          System.out.print("a/b...a? ");
          int n1 = kb.nextInt();
          System.out.print("a/b...b? ");
          int n2 = kb.nextInt();
          System.out.printf("%d / %d = %d \n", n1, n2, n1 / n2);    // 예외 발생 지점
       }
       catch(ArithmeticException | InputMismatchException e) {
          System.out.println(e.getMessage());
       }
   
       System.out.println("Good bye~~!");
    }
}
```
* `|`를 사용해서 하나의 `catch 문`에서 여러 예외 클래스를 처리하게 만들었다.              
* 당연한 얘기지만, 동일한 예외처리 로직을 실행할 때 `|`를 사용해서 묶어줘야 한다.           

하지만, 다중 `catch 문`이 모든 상황에서 사용되는 것은 아니다.     
   
<img width="1045" alt="스크린샷 2021-01-16 오후 8 42 50" src="https://user-images.githubusercontent.com/50267433/104810949-7853ba80-583b-11eb-84a3-456c2af90fe4.png">  
  
   
```java
public class ExceptionStudy {
    public static void main(String[] args) {
        Scanner kb = new Scanner(System.in);

        try {
            System.out.print("a/b...a? ");
            int n1 = kb.nextInt();
            System.out.print("a/b...b? ");
            int n2 = kb.nextInt();
            System.out.printf("%d / %d = %d \n", n1, n2, n1 / n2);    	// 예외 발생 지점
        } catch (Exception e) {						
            System.out.println(e.getMessage());
        } catch (InputMismatchException e) {				// 컴파일 에러 발생 
            System.out.println(e.getMessage());
        }

        System.out.println("Good bye~~!");
    }
}
```
* `InputMismatchException` 에서 에러가 생겼다.       
* 컴파일 에러 메시지를 읽어보면 이미 예외를 잡았다는 메시지가 나온다.    
            
`catch 문`에서는 예외 클래스들간의 계층 구조를 따져 사용을 제한한다.                   
즉, 상위 예외 클래스가 이미 기술되었다면 하위 예외 클래스는 사용할 수 없다는 뜻이다.        
이는 `'|' 를 이용한 다중 catch 문` 에서도 마찬가지이다.      
           
<img width="1051" alt="스크린샷 2021-01-16 오후 9 01 31" src="https://user-images.githubusercontent.com/50267433/104811354-28c2be00-583e-11eb-9c5c-ac90ec9e4985.png">   

           
```java
public class ExceptionStudy {
    public static void main(String[] args) {
        Scanner kb = new Scanner(System.in);

        try {
            System.out.print("a/b...a? ");
            int n1 = kb.nextInt();
            System.out.print("a/b...b? ");
            int n2 = kb.nextInt();
            System.out.printf("%d / %d = %d \n", n1, n2, n1 / n2);      // 예외 발생 지점
        } catch (Exception  | InputMismatchException e) {		// 컴파일 에러 발생  
            System.out.println(e.getMessage());
        } 

        System.out.println("Good bye~~!");
    }
}
```

앞서 말했듯이, 상위 예외 클래스가 이미 기술되었다면 하위 예외 클래스는 사용할 수 없다.   
하지만 이러한 원칙은 '예외 클래스의 지정된 순서'에 기안하여 일어나는 경우이다.
즉, 상위 클래스가 나중에 기술된다면 컴파일 에러가 발생하지 않는다.   

<img width="1057" alt="스크린샷 2021-01-16 오후 9 07 19" src="https://user-images.githubusercontent.com/50267433/104811459-ee0d5580-583e-11eb-96a6-9438f224afdb.png">

```java
public class ExceptionStudy {
    public static void main(String[] args) {
        Scanner kb = new Scanner(System.in);

        try {
            System.out.print("a/b...a? ");
            int n1 = kb.nextInt();
            System.out.print("a/b...b? ");
            int n2 = kb.nextInt();
            System.out.printf("%d / %d = %d \n", n1, n2, n1 / n2);    // 예외 발생 지점
        } catch (InputMismatchException e){
            System.out.println(e.getMessage());
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }

        System.out.println("Good bye~~!");
    }
}
```
* `InputMismatchException` 이후에 `Exception` 예외처리를 진행했고 문제가 없다.  


<img width="1023" alt="스크린샷 2021-01-16 오후 9 07 50" src="https://user-images.githubusercontent.com/50267433/104811496-36c50e80-583f-11eb-9568-c0d11349bb49.png">  
  
```java
public class ExceptionStudy {
    public static void main(String[] args) {
        Scanner kb = new Scanner(System.in);

        try {
            System.out.print("a/b...a? ");
            int n1 = kb.nextInt();
            System.out.print("a/b...b? ");
            int n2 = kb.nextInt();
            System.out.printf("%d / %d = %d \n", n1, n2, n1 / n2);      // 예외 발생 지점
        } catch (InputMismatchException | Exception e) {		// 컴파일 에러 발생 
            System.out.println(e.getMessage());
        }

        System.out.println("Good bye~~!");
    }
}
```
단, `'|'를 이용한 다중 catch 문` 처리는 동일한 순서로 처리한다고 가정하기에     
상위 예외 클래스와 하위 예외클래스를 동시에 사용하면 컴파일 에러가 발생한다.        
    
`다중 catch 문`은 이미 선언된 클래스의 계층 구조를 따져 추가될 클래스에 제한을 둔다.   
그렇기에 예외 처리를 할 때 예외 클래스간의 계층 관계를 생각하면서 기술하자.     
     
## throw       
> throw 를 간략히 말하면 이렇다. **예외 발생시키기**    
   
throw를 사용하면 프로그래머가 고의로 예외를 발생시킬 수 있다.    
   
**방법**    
1. 연산자 new를 이용해서 발생시키려는 얘외 클래스를 만든다.       
2. `trhow`를 이용해서 예외를 발생시킨다.    
    
프로그래머가 고의로 예외 클래스의 객체를 만들어 예외를 발생시킬 수 있다.                
예외가 발생되면 `try-catch`문으로 처리하거나 `throws`로 던져야 하며             
주로, 사용자가 정의한 예외 클래스를 특정 시점에 객체로 만들어 예외를 발생시킬 때 사용한다.       
        
```java
       Board board = BoardRepository.findById(id).orElseThrow(() -> new
                IllegalArgumentException("해당 게시판 아이디가 없습니다. id=" + id));
```   
필자 같은 경우는 `JpaRepository`에서 반환된 `Optional<>` 클래스에서     
`orElseThrow()` 메서드를 통해 반환된 객체가 없다면 에러를 발생시키도록 정의하기도 했다.       
    
## throws    
한 가지 의문점을 제시해보겠다.       
`RuntimeException`을 제외한 예외 클래스들은 `try-catch 문`을 사용해야한다고 말한다. 
   
   
   
## finally
## trywithResource
# 커스텀한 예외 만드는 방법
# 클린코드에서 말하는 예외처리     
## 미확인(unchecked) 예외를 사용      
> 프로그래머들은 **확인된(checked) 예외**의 장단점을 놓고 논쟁을 벌여왔다.          
> 하지만 안정적인 소프트웨어를 제작하는 요소로 반드시 필요하지 않다는 사실이 분명해졌다.    
   
||Checked Exception|Unchecked Exception|   
|-|-----------------|-------------------|       
|처리 여부|반드시 예외를 처리해야 함|명시적인 처리를 강제하지 않음|  
|확인 시점|컴파일 단계|실행 단계|    
|예외 발생시 트랜잭션 처리|Roll-back 하지 않음|Roll-back 함|   
|대표 예외|Exception의 상속받는 하위 클래스 중<br> Runtime Exception을 제외한 모든 예외<br> * IOException<br>* SQLException|Runtime Exception 하위 예외<br>* NullPointerException<br>* IllegalArgumentException<br>* IndexOutOfBoundException<br>* SystemException|  
   
**확인된(checked) 예외를 사용한 코드**    
```java
public void catchFileInputException() {
    try { 
        a();
    } catch (FileInputException e) {
        throw new StorageException("retrieval error", e);
    }
}

public void a() throws FileInputException { 
    aa(); 
}

public void aa() throws FileInputException {
    aaa();
}

public void aaa() throws FileInputException {
    FileInputStream stream = new FileInputStream(sectionName);
    stream.close();
}
```
* 확인된(checked) 예외는 OCP를 위반한다.   
* 메서드에서 예외를 던졌는데 `catch` 문이 위에 있다면 모든 선언부에 예외를 정의해야한다.   
* 즉, 하위 단계에서 코드를 수정하면 모든 상위 단계 메서드 선언부를 고쳐야한다.       
* 모듈과 관련된 코드가 바뀌지 않아도 선언부가 바뀌었으므로 모듈을 다시 빌드 후 배포 해야한다.
    
대규모의 시스템에 호출이 일어나는 방식을 살펴보자         
최상위 함수가 아래 함수를 호출하고 아래 함수는 더 아래 함수를 호출한다.        
만약 최하위 함수에서 기존과 다른 `chekced 예외`가 발생한다면?        
아래와 같은 동작을 취해야 한다.        
  
1. `catch 블록`을 가진 상위 메서드에 새로운 예외 처리를 추가한다.   
2. 연관된 메서드의 선언부에 새로운 예외를 추가해줘야 한다.     
       
결과적으로 최하단부터 최상단까지 연쇄 작용이 일어나고        
`throws` 경로에 위치하는 모든 함수는 최하위 함수에서 던지는 예외를 알아야 하므로 캡슐화가 깨진다.       
  
때로는 확인된(checked) 예외도 유용하다.      
아주 중요한 라이브러리를 작성한다면 모든 예외를 잡아야 한다.     
하지만 일반적인 애플리케이션은 의존성이라는 비용이 이익보다 크므로 미확인 예외를 사용하는 것이 좋다.   


## 예외에 의미를 제공하라      

```java
public List<RecordedGrip> retrieveSection(String sectionName) {
    try {
        FileInputStream stream = new FileInputStream(sectionName);
	stream.close();
    } catch (FileInputException e) {
        throw new StorageException("retrieval error", e);
    }
    return new ArrayList<RecordedGrip>();
}
```
* 예외를 던질 때는 전후 상황을 충분히 덧붙인다.   
* 그러면 오류가 발생하는 원인과 위치를 찾기가 쉬워진다.  
* 오류 메시지에 정보를 담아 예외와 함께 던진다.   
* 실패한 연산 이름과 실패 유형도 함께 언급한다.   
* 로깅 기능을 사용한다면 catch 블록에서 오류를 기록하도록 충분한 정보를 남겨준다.   

## 예외 클래스를 정의하라   
> 오류를 정의할 때 가장 중요한 관심사는 **오류를 잡아내는 방법**이다.      
    
오류를 분류하는 방법은 수없이 많다.   
오류가 발생한 위치로 분류하거나 오류 유형으로 분류가 가능하다.   

다음은 오류를 형편없이 분류한 사례다   

```java
ACMEPort port = new ACMEPort(12);

try {
    port.open();
} catch (DeviceResponseException e) {
    reportPortError(e);
    logger.log("Device response exception", e);
} catch (ATM1212UnlockedException e) {
    reportPortError(e);
    logger.log("Unlock exception", e);
} catch (GMXError e) {
    reportPortError(e);
    logger.log("Device response exception");
} finally {
    ...
}
```
* 외부 라이브러리를 호출하는 코드   
* 외부 라이브러리가 던질 예외를 모두 잡아내고 있다.   
* 하지만, 위 코드는 중복이 심하고 에러마다 기능을 추가해야 된다면 코드도 길어질 것이다.
* 즉, 시간이 지날수록 코드가 길고 복잡한 형태를 띄게 될 것이다.  

## 감싸기 기법      
> 호출 라이브러리 API를 감싸면서 예외 유형을 하나로 반환하게 만드는 기법        
          
```java
ACMEPort port = new ACMEPort(12);

try {
    port.open();
} catch (DeviceResponseException e) {
    reportPortError(e);
    logger.log("Device response exception", e);
} catch (ATM1212UnlockedException e) {
    reportPortError(e);
    logger.log("Unlock exception", e);
} catch (GMXError e) {
    reportPortError(e);
    logger.log("Device response exception");
} finally {
    ...
}
```
* 위 코드는 예외에 대응하는 방식이 예외 유형과 무관하게 거의 동일하다.   
* 즉, 코드를 간결하게 고치기가 아주 쉬운 코드이다.  
* **Wrapper 클래스로 호출하는 라이브러리 API를 감싸면서 예외 유형을 하나로만 반환하면 된다.**       

```java
 public class LocalPort {
     private ACMEPort innerPort;

     public LocalPort(int portNumber) {
         innerPort = new ACMEPort(portNumber);
     }

     public void open() {
         try {
             innerPort.open();
         } catch (DeviceResponseException e) {
             throw new PortDeviceFailure(e);
         } catch (ATM1212UnlockedException e) {
             throw new PortDeviceFailure(e);
         } catch (GMXError e) {
             throw new PortDeviceFailure(e);
         }
     }
     ...
 }
```
* Wrapper 클래스는 단순히 인스턴스의 메서드를 호출한다.   
* 이 과정에서 대응 방식이 동일한 예외를 `PortDeviceFailure` 예외로 다시 던진다.   
        
```java
 LocalPort port = new LocalPort(12);
 try {
     port.open();
 } catch (PortDeviceFailure e) {
     reportError(e);
     logger.log(e.getMessage(), e);
 } finally {
     ...
 }
```
* 외부에서는 Wrapper클래스의 메서드를 호출한다. 
  * 이너 클래스의 메서드를 수행하는 메서드      
* 이전과 달리 Wrapper클래스의 예외 처리로 인해 `PortDeviceFailure` 예외만 처리해주면 된다.   
       
실제로 외부 API를 사용할 때는 감싸기 기법이 최선이다.      
외부 API를 Wrapper클래스로 감싸면 아래와 같은 장점이 있다.      
   
* 에러 처리가 간결해진다.
* 외부 라이브러리와 프로그램 사이의 의존성이 크게 줄어든다.
* 다른 라이브러리로 변경할 시 비용이 적다.  
* 외부 API 호출 대신 테스트 코드를 넣는 방법을 사용해 프로그램 테스트가 쉬워진다.
* 무엇보다 특정업체의 외부 API 설계 방식에 의존하지 않아도 된다.   
  * 프로그램이 사용하기 편리한 API를 개발자가 직접 정의할 수 있다.   
     
흔히 예외 클래스가 하나만 있어도 충분한 코드가 많다.      
예외 클래스에 포함된 정보로 오류를 구분해도 괜찮은 경우가 그렇다.      
한 예외는 잡아내고 다른 얘외는 무시해도 괜찮은 경우라면 여러 예외 클래스를 사용하자   

## 정상 흐름을 정의하라         
> 예외 처리가 꼭 필요한 것이 아니라면 정의하지 않는 것이 좋다.    
        
```  
외부 API를 감싸 독자적인 예외를 던지고, 코드 위에 처리기를 정의해 중단된 계산을 처리      
```                 
Wrapper 클래스를 이용하여 코드를 잘 분리하면 깨끗하고 간결한 알고리즘이 보인다.              
하지만 **예외 처리 또한, 가독성을 낮추는 작업이기에 예외를 발생시키지 않는 코드를 작성하는 것이 좋다.**        
즉, 예외 처리에 집중이되어 보다 좋은 코드를 작성할 수 있는 기회를 놓치지 않길 바란다.         
           
```java
 try {
     MealExpenses expenses = expenseReportDAO.getMeals(employee.getID());
     m_total += expenses.getTotal();
 } catch(MealExpencesNotFound e) {
     m_total += getMealPerDiem();
 }
```
* 위 코드는 총계를 계산하는 코드이다.
* 식비를 비용으로 청구했다면 직원이 청구한 식비를 총계에 더한다.   
* 식비를 비용으로 청구하지 않았다면 일일 기본 식비를 총계에 더한다.   
* 예외 처리를 이용하여 일일 기본 식비를 총계에 더하는 알고리즘이다.   
* 하지만 예외가 논리를 따라가기 어렵게 만들고 있다.  

**getTotal CASE 1 and 2**
```java
 public class PerDiemMealExpenses implements MealExpenses {
     MealExpenses someThing
     public int getTotal() {
         try {
	     return someThing.getTotal();
	 } catch (NullPointerException e) {
	     throw new MealExpencesNotFound(e);
	 }
     }    
 }
```
* 예외를 던지는 `getTotal()` 메서드이다. 
* `NullPointerException`이 발생하면 Wrapper 클래스로 `MealExpencesNotFound`를 던질 것이다.         
* 하지만 결과적으로 호출한 곳에서 예외 처리를 진행하므로 코드의 가독성을 낮추는 문제를 야기한다.   

## 특수 사례 패턴  
```java
     MealExpenses expenses = expenseReportDAO.getMeals(employee.getID());
     m_total += expenses.getTotal();
```
```java
 public class PerDiemMealExpenses implements MealExpenses {
     public int getTotal() {
         // 기본값으로 일일 기본 식비를 반환한다. 
     }    
 }
``` 
* `MealExpenses` 인터페이스를 구현하는 `PerDiemMealExpenses` 클래스를 새로 정의했다.    
* `PerDiemMealExpenses` 클래스는 `NullPointerException`을 방지하기 위한 **특수 사례 클래스**이다.   
* 즉, 특수한 동작이 처리되지 않을 경우 `PerDiemMealExpenses` 객체를 반환하게끔 만드는 것이다.     
* 예제로 빗대어 보면 식비를 비용으로 청구하지 않았다면 `PerDiemMealExpenses` 객체를 반환한다.    
* 물론, `expenseReportDAO.getMeals()`에서는 이에 대한 처리를 해주어야한다.         
* 이같이 '특수 사례 클래스'를 만들어 `Null`이나 `NullPointerException`을 처리하는 방법을 '특수 사례 패턴'이라 한다. 
* 클래스나 객체가 예외적인 상황을 캡슐화해서 처리하므로 예외적인 상황을 처리할 필요가 없어진다.    
* https://johngrib.github.io/wiki/null-object-pattern/     
   
## null을 반환하지 마라 
> null을 반환하는 행위는 우리가 흔히 저지르는 오류 유발 행위이다.    

```java
public void registerItem(Item item) {
	if (item != null) {
		ItemRegistry registry = peristentStore.getItemRegistry();
		if (registry != null) {
			Item existing = registry.getItem(item.getID());
			if (existing.getBillingPeriod().hasRetailOwner()) {
				existing.register(item);
			}
		}
	}
}
```
* 대부분의 개발자는 이런 코드가 나쁘지 않다고 생각하는데 사실 나쁜 코드이다.
* 호출자에게 null을 체크할 의무를 준다.      
* `NullPointerException` 이 발생할 위험이 있다.        
* `null 체크` 갯수에따라 분기가 나눠져 처리해야할 코드가 많아지므로 복잡성이 커진다.       
* 누구 하나라도 `null 체크`를 빼먹으면 통제 불가능해진다.   
      
이 같은 문제를 해결하기 위해서 주로 2가지 방법을 사용한다.       
    
1. Wrapper 클래스를 이용해서 예외를 던진다.      
2. '특수 사례 패턴'의 '특수 사례 객체'를 이용해서 코드를 단일화 시킨다.       

## 특수 사례 패턴 
**개선 전**
```java
List<Employee> employees = getEmployees();
if(employees != null) {
	for(Employee e : employees) {
		totalPay += e.getPay();
	}
}
```
* `getEmployees()` 메서드는 `null`을 반환하기에 이를 처리해줘야한다.   

**개선 후** 
```java
public List<Employee> getEmployees() {
	if (..직원이 없다면..)
		return Collections.emptyList();
}
```
```java
List<Employee> employees = getEmployees();
for(Employee e : employees) {
	totalPay += e.getPay();
}
```
* `getEmployees()` 메서드에서 특정 조건을 검사해 '빈 리스트'를 반환하도록 코드를 변경했다.     
* 여기서 `emptyList()`는 '특수 사례 객체'를 리턴하는 메서드라 생각하면 된다.      
* 리턴된 값은 내부가 어떻든 `List<Employee>` 형태가 동일하므로 코드가 단일화 된다.   
* 결과적으로 코드가 간결해지고 `NullPointerException`이 발생할 확률도 줄어들었다.  

## null 을 전달하지 마라   
> null을 반환하는 메서드보다 메서드로 null 을 전달하는 방식이 더 나쁘다.      
   
정상적인 인수로 null을 기대하는 API가 아니라면 메서드로 null을 전달하는 코드는 최대한 피한다.   

```java
public class MetricsCalculator {
    public double xProjection(Point p1, Point p2) {     
        return (p2.x - p1.x) * 1.5; // 일부러 절차 지향적인 클래스로 만든것     
    }
    ...
}
```
* 두 지점 사시의 거리를 계산하는 간단한 메서드다.       

```java
calculator.xProjection(null, new Point(12, 13));
```
* 만약 인수로 null을 전달하면 어떤 일이 발생할까?        
* 당연히 `NullPointerException`이 발생한다.   

```java
public class MetricsCalculator {
    public double xProjection(Point p1, Point p2) {     
        if(p1 == null || p2 == null) {
	    throw InvalidArgumentException(
	        "Invalid argument for MetricsCalculator.xProjection");
	}
        return (p2.x - p1.x) * 1.5; // 일부러 절차 지향적인 클래스로 만든것     
    }
    ...
}
```
* `null`일 경우 `InvalidArgumentException` 예외 클래스를 던지도록 했다.       
* `NullPointerException` 보다는 조금 나을지 모르겠다.          
* 하지만, `InvalidArgumentException`을 잡아내는 `try-catch` 처리기가 필요하다.             
* 그렇다면 `InvalidArgumentException` 예외를 어떻게 처리해야할까?     
     
```java
public class MetricsCalculator {
    public double xProjection(Point p1, Point p2) {     
        assert p1 != null : "p1 should not be null";
	assert p2 != null : "p2 should not be null";
	return (p2.x - p1.x) * 1.5;    
    }
}
```
* assert 키워드를 사용한 방법은 코드를 읽기는 편하지만 문제를 해결하지는 않았다.   
* 누군가 null을 전달하면 여전히 실행 오류가 발생하기 때문이다.   
   
사실 대다수의 프로그래밍 언어는 호출자가 실수로 null을 넘기는 것을 처리하는 방법이 없다.   
그렇기에 애초에 null을 넘기지 못하도록 금지하는 정책이 합리적인 방법이라 말할 수 있다.  
즉, 인수로 null이 넘어오면 코드에 문제가 있다는 말이며 이를 주의하면서 코드를 작성하자   
   
**자바에서 assert 키워드 사용하기**        
* 자바에서 assert 키워드를 사용하려면 몇 가지 준비사항이 있다.      
* 방법은 해당 사이트에서 참조 : https://offbyone.tistory.com/294      
      
 
