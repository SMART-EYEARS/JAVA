# 들어가면서
> **목표 :** 자바의 상속에 대해 학습하세요.
   
[1. 자바 상속의 특징](#자바-상속의-특징)     
[2. super 키워드](#super-키워드)   
[3. 메소드 오버라이딩](#메소드-오버라이딩)   
[4. Dynamic Method Dispatch](#dynamic-method-dispatch)   
[5. 추상 클래스](#추상-클래스)   
[6. final 키워드](#final-키워드)   
[7. Object 클래스](#object-클래스)    
     
# 자바 상속의 특징
> 상속 : 연관된 일련의 클래스들에 대해 공통적인 규약을 정의한다.     
   
**'상속'이 등장하기 이전에는**          
<img width="802" alt="스크린샷 2021-01-04 오후 5 47 16" src="https://user-images.githubusercontent.com/50267433/103517151-02ebff80-4eb5-11eb-92d1-c1585fcd9682.png">
<img width="802" alt="스크린샷 2021-01-04 오후 5 46 18" src="https://user-images.githubusercontent.com/50267433/103517160-05e6f000-4eb5-11eb-9f02-d6697c90223c.png">
    
연관된 클래스에 공통으로 사용되는 코드들이 중복되어 존재하고 있는 경우,            
공통 규정이 바뀌면, 모든 클래스를 조회하여 해당 코드들을 일일히 수정해야했다.        
또한, 공통된 규정이 무엇인지 알기 위해서는 코드를 읽고 파악해야하므로 시간이 오래 걸렸다.             
이로 인해, 생산성이 매우 떨어졌으며 유지보수에도 많은 클래스를 관리해야하는 문제가 있었다.     

**'상속'이 등장한 이후에는**            
<img width="802" alt="스크린샷 2021-01-04 오후 5 53 24" src="https://user-images.githubusercontent.com/50267433/103517699-e603fc00-4eb5-11eb-87e1-25e7222cee60.png">
<img width="802" alt="스크린샷 2021-01-04 오후 5 54 00" src="https://user-images.githubusercontent.com/50267433/103517722-f025fa80-4eb5-11eb-97ca-1927cf44abf7.png">
    
적은양의 코드로 새로운 클래스를 작성할 수 있게 되었고    
상위 클래스의 코드만 수정하면 하위 클래스의 코드들도 한 번에 관리할 수 있게 되었다.  
즉, 코드의 재사용성을 높이고, 중복을 제거하게 되면서 생산성과 유지보수성이 크게 좋아졌다.             
   
**하지만, 상속은 코드 재사용성을 높이는 기능이지만 항상 최선은 아니다**           
무분별한 상속의 사용은 오히려 코드를 읽기 어렵게 만들며 구조가 복잡해진다.     
그렇기에 이펙티브 자바에서는 아래와 같은 경우에는 안전하다고 말하고 있다.   
* 클래스가 상속을 위해 특별히 설계되었을 경우             
* 구조화가 잘 된 클래스를 확장의 목적으로 상속하는 경우  
* 동일 개발자가 같은 패키지내에 존재하는 하위 클래스와 상위 클래스를 통제하는 경우 
* 이 부분은 [thewing님의 블로그](https://sujl95.tistory.com/32?category=941455) 참조       

**상속의 장점**    
1. 기존에 작성된 클래스를 재활용할 수 있다.        
2. 자식 클래스 설계 시 중복되는 멤버를 미리 부모 클래스에 작성해 놓으면,       
자식 클래스에서는 해당 멤버를 작성하지 않아도 된다.           
3. **클래스 간의 계층적 관계를 구성함으로써 다형성의 문법적 토대를 마련한다.**         

**상속의 단점**
1. 기능 추가/ 변경시에 예외나 버그가 발생하게 되면 어디에서 발생한지 예측을 하기가 힘들다.          
2. 불필요한 기능을 원치 않는다 해도 상속해야한다.              
3. 하위 클래스는 상위 클래스와 강하게 결합되어 캡슐화를 깨뜨린다.                   
**취약한 기반 클래스 문제 발생 :** 부모 클래스의 변경에 의해 자식 클래스가 영향을 받는다.       
    
**상속 용어 설명**       
<img width="802" alt="스크린샷 2021-01-04 오후 6 00 13" src="https://user-images.githubusercontent.com/50267433/103518224-b73a5580-4eb6-11eb-8aaf-6a01c4a7fa9f.png">
   
* 상위 클래스 : 상속이 되는 대상, 하위 클래스에게 자신의 구성 요소를 상속해주는 클래스    
* 하위 클래스 : 상속을 받는 대상, 상위 클래스로부터 구성 요소를 상속받는 클래스      
  
**자바 상속의 특징**          
<img width="802" alt="스크린샷 2021-01-04 오후 6 02 36" src="https://user-images.githubusercontent.com/50267433/103518401-0f715780-4eb7-11eb-8f30-85ae63bc3220.png">
    
* C++에서는 다중 상속을 지원하는 것과 달리, 자바에서는 단일 상속만 가능하다.      
* 상속을 받은 클래스 또한 상속을 해주는 상위 클래스가 될 수 있다.      
* 모든 클래스들의 최상위 클래스는 Object 클래스이다.    

**코드로 알아보기**
```java
class Man {
    String name;

    Man() {}
    public Man(String name) {
        this.name = name;
    }

    public void tellYourName() {
        System.out.println("Man : My name is " + name);
    }
}

public class BusinessMan extends Man {
    String company;
    String position;

    public BusinessMan(String name, String company, String position) {
        // this.name = name; 이렇게 접근하는 것은 좋지않다.     
        super(name);
        this.company = company;
        this.position = position;
    }

    public void tellYourInfo() {
        tellYourName();
        System.out.println("repeat : My name is" + name);
        System.out.println("My company is " + company);
        System.out.println("My position is " + position);
    }

    @Override
    public void tellYourName() {
        System.out.println("Override Business Man: My name is" + name);
    }
    
    public void tellYourName(boolean doRunSuper){
        if(doRunSuper)super.tellYourName();
        else tellYourName();
    }
    
}
```
* BusinessMan 클래스는 Man을 상속받았다.      
* 상속 받으면서 Man의 메서드와 변수를 접근할 수 있게 되었다.     

**'접근할 수 있게 되었다'의 진짜 의미**       
하위 클래스의 객체를 생성되면 내부적으로 상위 클래스의 객체도 함께 생성된다.                    
즉, 전체적으로 보면 하위 객체 메모리 안에 상위 객체가 존재하는 것이다.                     
만약, 상위 클래스에서 변수나 메서드에 `private` 선언을 하게 되면                
하위 클래스는 상위 클래스와 사실상 다른 클래스이므로 접근을 하지 못하게 된다.                  
그렇기에 코드를 사용하는 것이 아닌, 접근을 할 수 있는 권한을 가지게 되었다고 표현을 했다.           
재미있는 점은 그래도 하위 객체를 기준으로 하는 자료형이므로 동일한 해시코드를 반환한다.              

# super 키워드
> **super :** 상속받은 상위 클래스(객체)    

앞서, `this` 키워드에 대해서 이야기해보겠다.      
`this`는 키워드, 메서드 2가지 타입으로 존재하며 공통적으로 `객체,자기 자신`을 가리켰다.   

**`super`도 마찬가지이다.**   
`super`는 키워드, 메서드 2가지 타입으로 존재하며 공통적으로 **`상위 클래스`를 가리킨다.**

**super를 사용하는 경우**    
* 상위 클래스의 생성자를 호출할 때        
* 오버라이딩 되지 않은 상위 클래스의 메서드를 호출할 때    

**상위 클래스의 생성자를 호출할 때**
```java
    public BusinessMan(String name, String company, String position) {
        // 첫째 줄에 super()를 기술하지 않으면 상위 클래스는 디폴트 생성자가 호출된다.   
        this.name = name;  // 상위 클래스의 생성자 조건이 맞으면 사용은 가능하다.  
                           // 하지만 이렇게 사용하는 것은 생성자의 원칙에 어긋난다.   
        this.company = company;
        this.position = position;
    }
```
* **생성자 첫 줄에 `super()`를 기술하지 않으면 내부적으로 상위 클래스 디폴트 생성자를 호출한다.**           
* 상위 클래스의 인스턴스가 생성될 수 있는 조건이 맞으면 상위 클래스 변수에 직접 할당도 가능하다.     
* 하지만, 생성자는 객체가 생성될 때 값을 초기화 시켜주는 것과 달리      
상위 클래스 변수에 직접 할당하는 방법은 객체 생성 원칙에 알맞지 않다.        
* 그렇기에 위 같은 방법 보다는 `super()`를 이용해서 상위 클래스 인스턴스를 만들자.

```java
    public BusinessMan(String name, String company, String position) {
        super(name);        // this.name = name; 이렇게 사용하는 것은 생성자의 원칙에 어긋난다.
        this.company = company;
        this.position = position;
    }
```
* **super()는 생성자 첫 줄에만 기술할 수 있다.**        
* 왜냐하면 상위 클래스 객체가 먼저 생성되어야 하위 클래스 객체를 생성 가능하기 때문이다.          
* 생성자 첫 줄에 `super()`를 명시적으로 기술하면 상위 클래스 디폴트 생성자를 호출하지 않는다.      

**오버라이딩 되지 않은 상위 클래스의 메서드를 호출할 때**
```java
    public void tellYourName(boolean doRunSuper){
        if(doRunSuper)super.tellYourName();
        else tellYourName();
    }
```
* 오버라이딩 :        
하위 객체를 생성했을 때, 상위/하위 클래스에 동일한 구조의 메서드가 존재한다면        
하위 클래스를 기준으로 해당 메서드를 호출하는 것이다.                    
* 하위 객체를 생성하면 메서드는 오버라이딩된 메서드로만 호출된다.        
* 만약, 하위 객체에서 상위 객체의 메서드를 사용하고자 하면 `super`를 사용한다.            

# 메소드 오버라이딩
# Dynamic Method Dispatch
# 추상 클래스
# final 키워드
# Object 클래스
