# 들어가면서      
> **목표 :** 자바의 인터페이스에 대해 학습하세요.     
 
[1. 인터페이스란?](#)   
[2. 인터페이스 정의하는 방법](#)        
[3. 인터페이스 구현하는 방법](#)     
[4. 인터페이스 레퍼런스를 통해 구현체를 사용하는 방법](#)    
[5. 인터페이스 상속](#)   
[6. 인터페이스의 기본 메소드 (Default Method), 자바 8](#)    
[7. 인터페이스의 static 메소드, 자바 8](#)  
[8. 인터페이스의 private 메소드, 자바 9](#)    


# 인터페이스    
> **인터페이스 :** 추상클래스가 '미완성 설계도'라면 인터페이스는 '기본 설계도'이다.    

```java
interface sampleInterface {
    public void getPercentage(int n);
}

class Sample implements sampleInterface {
    public double getPercentage(){
        ...
    }
}
```
인터페이스는 자바에서 클래스들이 구현해야 하는 동작을 지정하는데 사용되는 추상 자료형이다.    
추상클래스보다 추상화 정도가 높아서 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다.   
즉, 인터페이스는 추상 메서드만을 가질 수 있다.        
            
인터페이스는 추상클래스처럼 불완전한 것이기에               
그 자체만으로 사용되기 보다는 클래스에 구현되어 사용이 되며              
무엇보다도 클래스 생성에 강한 규약을 주어 공통된 특징의 클래스로 강제시킨다.         
       
인터페이스는 OOP의 꽃이며 OCP를 실현시키는 본질적인 기술이다.       
그러니 인터페이스를 문법적으로 단순히 공부하는 것이 아니라 최대한 많은 것을 느껴야한다.     
  
# 인터페이스 정의하는 방법
인터페이스를 구현하는 기술에는 여러 내부기능과 기술들이 존재한다.    

**인터페이스 정의 포맷**
```java
[public] interface [인터페이스 이름] {
    [접근지시자][abstract][반환형][추상 메서드 이름](매개변수..);
}
```
* 클래스와 마찬가지로 소스파일 이름이 인터페이스 이름이면 `public`을 붙인다.  
* interface 키워드를 작성한 후 인터페이스 이름을 사용한다.  
* '추상 메서드' 정의는 일반 메서드와 동일하게 정의하나 로직을 기술하지 않는다.   
* 추상메서드의 접근지시자로 `private`는 올 수 없다.   
* 인터페이스의 추상메서드는 `public abstract`가 기본으로 선언되어 생략 가능하다.        
* 인터페이스의 디폴트메서드는 `default` 접근지시자를 사용하고 메서드를 정의해야한다.(자바8)      

# 인터페이스 구현하는 방법
**일반적인 구현방법**
```java
interface sampleInterface {
    void sampleAbstractMethod(String parameter);
}

class Sample implements sampleInterface {
    public void sampleAbstractMethod(String parameter) {
        System.out.println(parameter);
    }
}
```
* 클래스는 상속이라는 표현을 사용하지만 인터페이스는 **구현**이라는 표현을 사용한다.    
* `implements` 키워드를 통해 인터페이스를 구현한다.       
* 클래스는 인터페이스에 정의된 모든 추상 메서드를 구현해야 한다.    
  
클래스에서 인터페이스를 구현하는데 가장 중요한 것은         
추상 메서드의 접근지시자보다 더 넓은 접근지시자를 선언할 수 없다는 것이다.      

```java
    public abstract[반환형][추상 메서드 이름](매개변수..);
```
사실, 이러한 문법적 오류에 기반한 것인지       
인터페이스의 추상 메서드는 항상 `public`이 붙는다.     
정확히 말하면 추상 메서드 키워드까지 더한 `public abstract`가 붙는다.      
그렇기에 구현 클래스에서의 접근지시자 선정은 매우 자유로워졌다.       
     
```java
interface sampleInterface {
    public abstract void sampleAbstractMethod(String parameter);
}

class Sample implements sampleInterface {
    public void sampleAbstractMethod(String parameter) {
        System.out.println(parameter);
    }
}
```       
* `public abstract`를 붙여서 추상 메서드를 정의한다.           
* 하지만, `public abstract`는 생략하기에 대부분 `public`만 기술한다.         
        
# 인터페이스 레퍼런스를 통해 구현체를 사용하는 방법
자바에서는 표준으로 정의하고 있는, 즉 '미리 정의된' 함수형 인터페이스들이 있다.      
함수형 인터페이스란 인터페이스의 추상 메서드가 1개인 메서드를 의미한다.      

```java
@FunctionalInterface
interface SampleInterface {
    void sampleAbstractMethod();
}
```   
   
클래스는 `IS-A` 관계로 상속에 있어 물려줄 구성 요소가 적당히 많으면 좋다.       
반대로 인터페이스는 `Has-A` 관계를 가지기에 추상메서드의 갯수가 적을수록 이상적이다.                     
추상메서드를 1개만 이같이 이상적인 형태의 인터페이스를 함수형 인터페이스라 말한다.          
추상메서드가 1개인데 여러개의 default, static 메서드를 가져도 함수형 인터페이스이다.     
참고로 `@FunctionalInterface`를 통해 함수형 인터페이스 정의를 강제할 수 있다.         

   
**본론으로**       
자바에서 표준으로 제공하는 인터페이스는 아래와 같다.      

|인터페이스|추상 메서드|
|-------|--------|
|`Predicate<T>`|`boolaen test(T t)`|
|`Supplier<T>`|`T get()`|
|`Consumer<T>`|`void accept(T t)`|
|`Function<T, R>`|`R apply(T t)`|
    
이런 함수형 인터페이스와 추상형메서드에 대한 사용은 조금 복잡할 수 있다.       
조금 복잡하더라도 양해 부탁드리고 아래 로직을 반복해서 읽기를 바란다.  
물론, 내일중으로 그림을 그려 설명할 예정이다.       
      
```
AbstractClass 의 AbstractMethod 존재      
AbstractMethod 매개변수로 함수형 인터페이스를 원함       
AbstractMethod 내부에서 함수형 인터페이스의 추상 메서드를 사용하기 때문   

이를 이제 구현된 관점에서 보면 아래와 같다.    
AbstractClass 구현한 ConcreteClass
ConcreteClass 클래스이기에 AbstractMethod 구현한 ConcreteMethod 존재   
ConcreteMethod는 AbstractMethod를 따르기에 매개변수로 함수형 인터페이스를 원함     
정확히 말하면 다형성을 위해 함수형 인터페이스를 구현한 클래스를 원함     
함수형 인터페이스를 구현한 클래스는 함수형 인터페이스의 추상 메서드를 구현했고    
ConcreteMethod는 구현된 추상메서드를 사용하기 때문이다.      
```
    
**`Predicate<T>`**    
`boolaen test(T t)` 추상 메서드를 가진 함수형 인터페이스다.    
전달된 인자를 판단하여 true/false 값을 리턴하는데 사용된다.   

```java
@FunctionalInterface
public interface Predicate<T> {

    boolean test(T t); // 혼자만 추상형 메서드

    default Predicate<T> and(Predicate<? super T> other) {
        Objects.requireNonNull(other);
        return (t) -> test(t) && other.test(t);
    }

    default Predicate<T> negate() {
        return (t) -> !test(t);
    }

    default Predicate<T> or(Predicate<? super T> other) {
        Objects.requireNonNull(other);
        return (t) -> test(t) || other.test(t);
    }

    static <T> Predicate<T> isEqual(Object targetRef) {
        return (null == targetRef)
                ? Objects::isNull
                : object -> targetRef.equals(object);
    }
}

```
```java
    Stream<T> filter(Predicate<? super T> predicate);
```
```java
public class Main {
    public static void main(String[] args) {
        List<Integer> list = Arrays.asList(1,2,3,4,5);
        list = list.stream().filter(i -> i <= 3).collect(Collectors.toList());
        list.stream().forEach(System.out::println);
    }
}
```
* `Stream<E>`인터페이스의 `filter()`는 매개변수로 `Predicate<T>`구현 객체를 원한다.  
* `filter()` 내부적으로 `boolaen test(T t)`메서드를 사용하기 때문이다.   
* `filter()` 의 정확한 로직은 모르지만 `true`를 반환하는 요소만 남길 것이다.
   
    
**`Supplier<T>`**    
`T get()` 추상 메서드를 가진 함수형 인터페이스다.    
매개변수가 없으며 제네릭 타입으로 값을 리턴하는데 사용된다.   


```java
@FunctionalInterface
public interface Supplier<T> {
    T get();
}
```
```java
    // stream에서 예제를 찾기 힘들어 사용자가 정의한 메서드를 예시로 들었다.   
    // 소스코드 출처 : 윤성우의 열혈 java 프로그래밍

    public static List<Integer> makeIntList(Supplier<Integer> s, int n) {
        List<Integer> list = new ArrayList<>();
        for(int i = 0; i < n; i++)
            list.add(s.get());   // 난수를 생성해 담는다.
        return list;
    }
```
```java
public class InterfaceStudy {
    public static List<Integer> makeIntList(Supplier<Integer> s, int n) {
        List<Integer> list = new ArrayList<>();
        for(int i = 0; i < n; i++)
            list.add(s.get());   // 난수를 생성해 담는다.
        return list;
    }

    public static void main(String[] args) {
        Supplier<Integer> spr = () -> {
            Random rand = new Random();
            return rand.nextInt(50);
        };

        List<Integer> list = makeIntList(spr, 5); // Supplier 타입의 매개변수 사용
        System.out.println(list);

        list = makeIntList(spr, 10);
        System.out.println(list);
    }

}
```
* `makeIntList()`는 `Supplier<>`을 구현한 객체를 원하고 있다.   
* `makeIntList()` 내부적으로 구현된 `T get()`를 사용하기 때문이다.      
* `makeIntList()` 의 정확한 로직은 모르지만 반환된 요소들을 활용할 것이다.   



# 인터페이스 상속     
인터페이스는 상위 인터페이스의 구성 요소를 물려받을 수 있다.      
클래스와 인터페이스의 관계는 `implements`사용과 '구현'이라는 말을 사용한 것과 달리      
인터페이스와 인터페이스의 관계는 `extends`와 '상속'이라는 말을 사용한다.      
       
클래스에서 여러 인터페이스를 구현할 수 있는 것과 동일하게       
인터페이스에서는 여러 인터페이스를 상속할 수 있는 다중상속을 지원한다.    
    
|관계|class|interface|
|---|-----|---------|
|class|`extends`|`implements`|
|interface|`extends`|`extends`|
    
    
```java
interface InterfaceOne {
    void print();
}

interface InterfaceTwo{
    void print();
}

interface MultipleInheritance extends InterfaceOne, InterfaceTwo { }

class ConcreteClass implements MultipleInheritance{

    @Override
    public void print() {
        System.out.println();
    }

}
``` 
* 인터페이스는 여러 인터페이스에 대한 다중 상속이 가능하다.          
* 단, 메서드 시그니처가 동일하지만 반환형이 다른 경우 컴파일 에러를 발생시킨다.         
* 또한, 메서드 시그니처가 동일한 경우 하나의 메서드로 통일해서 오버라이딩을 진행한다.            
* 이를 통해 깨달은 점은 현업에서는 여러 API를 사용하므로 메서드 이름을 잘 지어야겠다는 것이다.      
   
# 인터페이스의 기본 메소드 (Default Method), 자바 8
# 인터페이스의 static 메소드, 자바 8
# 인터페이스의 private 메소드, 자바 9
