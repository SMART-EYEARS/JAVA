# 들어가면서 
> **목표 :** 자바의 프리미티브 타입, 변수 그리고 배열을 사용하는 방법을 익힙니다.

[1. 프리미티브 타입 종류와 값의 범위 그리고 기본 값](#프리미티브-타입-종류와-값의-범위-그리고-기본-값)   
[2. 프리미티브 타입과 레퍼런스 타입](#프리미티브-타입과-레퍼런스-타입)   
[3. 리터럴](#리터럴)   
[4. 변수 선언 및 초기화하는 방법](#변수-선언-및-초기화하는-방법)   
[5. 변수의 스코프와 라이프타임](#변수의-스코프와-라이프타임)   
[6. 타입 변환, 캐스팅 그리고 타입 프로모션](#타입-변환-캐스팅-그리고-타입-프로모션)   
[7. 1차 및 2차 배열 선언하기](#1차-및-2차-배열-선언하기)   
[8. 타입 추론, var](#타입-추론-var)  
[9. 라이브 강의](#라이브-강의)   
[10. 참고](#참고)   

# 프리미티브 타입 종류와 값의 범위 그리고 기본 값
> **프리미티브 타입 :** 사전에 정의 되어 있는 계산을 위한 실제 값을 저장하는 정적 데이터 타입이다.       
> 4가지 형태로 나뉘어졌으며 8개의 데이터 타입이 있다.  
   
**프리미티브 타입의 4가지 형태**               
|분류|설명|
|--|--|
|논리형|true/false 중 하나를 값으로 갖으며, 조건식과 논리적 계싼에 사용된다.|   
|문자형|문자를 저장하는데 사용되며, 변수에 하나의 문자만 저장할 수 있다.|    
|정수형|정수를 저장하는데 사용되며, 주로 int가 사용된다.<br>byte는 이진 데이터를 다룰 때 사용되며,<br>short은 C언어와의 호환을 위해 추가되었다.|    
|실수형|실수를 저장하는데 사용되며, 주로 double이 사용된다.|   
    
**프리미티브 타입의 크기와 범위 그리고 기본값**    
|데이터 타입|분류|크기|표현 가능 범위|기본값|
|----|-----|---|----------|-----|
|boolean|논리형|1 바이트|true, false|false|
|char|문자형|2 바이트|유니코드 문자|'\u0000'|
|byte|정수형|1바이트|-128 ~ 127|0|
|short|정수형|2바이트|-32,768 ~ 32,767|0|
|int|정수형|4바이트|-2,147,483,648 ~ 2,147,483,647|0|
|long|정수형|8바이트|-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807|0L|
|float|실수형|4바이트|+-(1.40 * 10 ^-45 ~ 3.40 * 10^38)|0.0f|
|double|실수형|8바이트|+-(4.94 * 10 ^-324 ~ 1.79 * 10^308)|0.0d|
       
* 변수를 생성할 때는 `int variable`과 같은 형식으로 선언해준다.       
* `boolean`을 제외한 나머지 7가지 타입은 서로 연산과 변환이 가능하다.    
* `char`는 문자 타입이지만 사실 [유니코드](https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C)와 매칭된 숫자를 저장한다.     
* `float`과 `double`은 정확한 값을 저장하는 것이 아닌 근사값을 저장하기애 다소 오차가 있다.         
* 단, 데이터 크기에 따라 `float은 6자리까지`, `double은 15자리까지`의 실수값을 보장한다.            
    
**기본값**
* 필드를 선언 했지만 **값을 할당하지 않았을 경우 미리 지정된 기본값이 들어간다.**      
* 정확히 말하면 초기화되지 않은 필드는 컴파일러에 의해 적절한 기본값이 할당된다.       
* 기본값은 일반적으로 데이터 유형에 따라 0 또는 null이 들어간다.    
* 그러나 이러한 기본값에 의존하는 것은 일반적으로 잘못된 프로그래밍 스타일이다.
* 이는 전역적으로 프리미티브 변수를 생성했을 때만 기본값이 들어가고
* 명시적으로 값을 할당하지 않았으므로 코드를 처음 본 동료 개발자는 혼란이 올 수 밖에 없다.    
* 때문에 기본값을 이용하는 것보다 값을 명시적으로 할당해주는 자세를 가지자.     
* 그리고 다시 한번 말한다. **기본값은 전역적으로 선언했을 때만 들어간다.**   
* **전역적으로 선언하지 않았을 경우 랜덤한 쓰레기 값이 변수에 할당된다.**     

   
# 프리미티브 타입과 레퍼런스 타입
> 자료형은 프리미티브 / 레퍼런스 이 2가지 타입으로 나뉜다.          
 
**프리미티브 타입 :**    
* Access By Value
* 지정된 데이터 형식에 맞는 고정된 크기의 공간을 할당하고 **`데이터 값`** 을 저장한다.   
* 변수 선언, 초기화, 할당시 값이 저장된 메모리 영역에 `직접적`으로 접근한다.       
* 즉, 변수에 새 값이 할당 될 때 변수에 할당된 메모리 블럭에 저장된 값을 바로 변경한다는 뜻이다. 
* 변수와 데이터 값은 스택(Stack)영역에 저장된다.     
* 지정된 데이터 형식이 있기 때문에 **자료형**이라는 용어를 사용한다.  

**레퍼런스 타입 :**  
|타입|할당 메모리|기본값|
|---|--------|----|
|배열 (Array)|4 bytes (객체의 주소값)|Null|		
|열거 (Enumeration)|4 bytes (객체의 주소값)|Null|
|클래스 (Class)|4 bytes (객체의 주소값)|Null|
|인터페이스 (Interface)|4 bytes (객체의 주소값)|Null|
   
* Access By Reference
* `객체의 주소(4 byte 정수)`만큼 공간을 할당하고 `데이터 값`이 아닌 `메모리 주소`를 저장한다. 
* 변수에 저장된 메모리 주소를 참조하여 실제 대상을 조작하기에 레퍼런스 타입이라 부른다.      
* 레퍼런스 타입을 자료형으로 가진 변수의 이름도 `참조 변수`라고 부른다. 
* 기본 값으로 null 값이 들어오며 할당하지 않을 경우 런타임시에 NullPointException이 발생할 수 있다.
* 변수는 스택(Stack)영역에 저장되지만 주소값을 통해 힙(Heap)으로 부터 데이터를 참조한다.
* 참고로 참조 대상들은 힙(Heap) 영역에 존재하므로 [GC 대상이 되어 삭제될 수 있다.](https://itmining.tistory.com/24) 
* 지정된 데이터 형식이 없기 때문에 **타입**이라는 용어를 사용한다.          
    
**프리미티브와 레퍼런스 메모리 비교**    
![데이터저장참조](https://user-images.githubusercontent.com/50267433/102764700-e7fe9300-43be-11eb-9ee4-f675a4fe9392.jpg)    

* 프리미티브 타입 : stack 영역에 변수와 데이터 값이 저장된다.      
* 레퍼런스 타입 : stack 영역에 변수와 주소값이 저장된다.       
  참조 변수들은 주소값을 통해 Heap에 존재하는 실제 데이터를 조작한다.    
  주소값은 대상의 가장 앞에 있는 메모리의 주소를 참조한다.   
  stack 과 달리 참조 대상은 순서가 랜덤하게 들어있다.   
   
**프리미티브와 레퍼런스 복사 비교**
* [이미지 참고 사이트](https://blog.geunho.dev/posts/java-deep-copy-shallow-copy/) 
* 프리미티브 타입 복사 :        
  * Access By Value : 값만 복사한다.        
  * 값만 복사하기 때문에 특정 변수의 값을 변경해도 다른 변수에 영향을 미치지 않는다.      
         
* 레퍼런스 타입 복사 :    
  * Access By Reference : 주소값을 복사한다.      
  * 주소값을 복사하기 때문에 특정 변수의 참조 대상의 값을 바꾸면 다른 변수에도 영향을 미친다.  

**String**    
* 사실 우리가 자주 사용하는 `String` 문자열 자료형도 레퍼런스 타입이다.      
* 하지만, 예외적으로 `java.lang.String` 문자열에 대한 특수 지원을 제공한다. 
* 예를 들면 문자열을 큰 따옴표로 묶으면 자동으로 새 String객체가 생성된다.
* 즉, `String str = "ABCDEFG";` 새로운 객체가 생성된다.      
* `String str = new String("ABCDEFG");`해도 새로운 객체가 생성된다.    
* 정확히 말하면 `"ABCDEFG";`는 기존 `"ABCDEFG"`가 저장된 메모리를 참조하는 것이다.       
* `new String("ABCDEFG");`은 메모리를 새로 할당해 `"ABCDEFG"`값을 넣고 참조한다.      

# 리터럴
> 리터럴은 변수에 넣는 변하지 않는 데이터를 의미한다.

```java
int year = 2020;
final int MAX_VALUE = 100;

// year : 변수
// MAX_VALUE : 상수
// 2020, 100 : 리터럴
```
   
* 현실에서는 `상수`를 변하지 않는 데이터라고 표현한다.             
* Java에서 `상수`는 변하지 않는 변수를 의미한다.        
* 그렇기 때문에 개발자들은 `리터럴`이란 표현을 사용한다.          

```java
int a = 10;
```    
기존에 변수는 실제 데이터 값을 저장한다고 했다.               
하지만, 이 같은 설명은 반은 맞고 반은 틀린 설명이다.           
리터럴 또한 데이터이므로 메모리 어딘가에 저장되어 있다가 사용되어야 한다.          

<img width="827" alt="스크린샷 2020-12-21 오후 10 14 03" src="https://user-images.githubusercontent.com/50267433/102782300-77666f00-43dc-11eb-9343-af7ee053c94a.png">
<img width="827" alt="스크린샷 2020-12-21 오후 10 23 12" src="https://user-images.githubusercontent.com/50267433/102782401-9f55d280-43dc-11eb-8572-bd5051c8e2f0.png">
<img width="827" alt="스크린샷 2020-12-21 오후 10 22 38" src="https://user-images.githubusercontent.com/50267433/102783158-db3d6780-43dd-11eb-9f7f-173746ea60a4.png">
   
* 코드를 입력하면 변수를 메모리에 할당하고 리터럴을 메모리에 할당한다.
* 할당하는 과정에서는 랜덤한 메모리로 할당한다.       
          
**의문점 해설**   
```java
public class Sample {
    public static void main(String[] args) {
        System.out.println(157);          // 157은 어떤 데이터형일까?    
         
        int i = 10;                       // 접미사가 없다.
        long l = 10L;                     // 접미사 L이 있다.
        float f = 10.00001F;              // 접미사 f가 있다.
        double d = 10.000000000000001D;   // 접미사 D가 있다.   

        long error = 10;                  // 에러 발생
    }   
}
```   
|종류|리터럴|접미사|
|---|----|----|
|논리형|false, true|없음|
|정수형|123, 0b0101, 077, 0xFF, 100L|L|
|실수형|3.14, 3.0e8, 1.4r, 0x1.0p-1|F,D|
|문자형|'A', '1', '\n'|없음|
|문자열|"ABC", "123", "A", "true"|없음|

* JVM은 기본 리터럴 타입에 대해서 정수형은 int로 실수는 double로 정의했다.    
* 그렇기 때문에 만약 다른 리터럴 타입을 사용하고 싶다면 알맞는 접미사를 붙여야 한다.   
* 참고로, int 와 double은 접미사를 붙이지 않아도 된다.   
* 그 외의 자료형에 대해 접미사를 붙이지 않을 경우에는 에러가 발생하니 주의하자    
* 또한, 논리형을 제외한 리터럴끼리는 연산이 가능하다.      
* `char`는 연산할 경우 숫자 형태로 연산이 진행되고    
* 나머지는 더 큰 데이터 크기를 가진 형태로 오토 캐스팅 되어 연산이 된다.      
* 한 쪽 피연산자가 문자열 리터럴 같은 경우는 나머지 피연산자를 문자열로 치환후 문자를 합친다.     

|특수문자|문자 리터럴|
|------|--------|
|tab|\t|
|backspace|\b|
|form feed|\f|
|new line|\n|
|carriage return|\r|
|역슬래쉬|\\|
|작은따옴표|\'|
|큰따옴표|\"|
|유니코드(16진수)문자|\u유니코드|

* 특수 문자 처리를 위한 리터럴도 존재한다.   
* **이스케이프 문자** 라고도 부른다.     

<img width="856" alt="스크린샷 2020-12-22 오전 9 53 18" src="https://user-images.githubusercontent.com/50267433/102836835-c1cc0800-443d-11eb-8dd2-c443eef6b4bf.png">  
<img width="856" alt="스크린샷 2020-12-22 오전 9 54 57" src="https://user-images.githubusercontent.com/50267433/102836858-cf818d80-443d-11eb-8ece-4cb1f5f434fd.png">  
<img width="857" alt="스크린샷 2020-12-22 오전 9 58 43" src="https://user-images.githubusercontent.com/50267433/102836875-d6a89b80-443d-11eb-8328-d5dfb5a09693.png">   
<img width="857" alt="스크린샷 2020-12-22 오전 10 08 07" src="https://user-images.githubusercontent.com/50267433/102836891-e0ca9a00-443d-11eb-91f2-8cdc1ad1892d.png">  
   
* 리터럴은 메모리에 어딘가에 계속 상주해있다.     
* 변수는 할당하려는 리터럴이 존재할 경우 자신에 메모리에 해당 값을 복사한다.    
* 만약 할당하려는 리터럴이 존재하지 않을 경우는 JVM이 메모리를 새로 할당 후 복사한다.     
* `==` 동등 연산자는 같은 메모리를 참조하면 같으면 true, 다르면 false를 리턴한다.       
* 변수는 서로 다른 메모리에 존재하지만 저장된 값이 같으면 true를 리턴 한다.
 

# 변수 선언 및 초기화하는 방법
> 여기서는 프리미티브 타입 변수 선언과 초기화에 대한 내용만 다룬다.
> 레퍼런서 타입 변수는 후에 클래스 주제에서 다루겠다.    
    
**변수 선언 :** 데이터를 저장하기 위해 자료형만큼의 메모리를 할당하고 이름을 붙이는 작업    
```java
int variable; // 변수 선언
variable = 10; // 초기화가 아니다. 할당이다!

```  
* 4byte 만큼의 메모리가 할당된다.          
* 해당 메모리에 `variable` 이라는 이름이 붙는다.         
* 값을 초기화해주지 않았으므로 int의 기본값 0이 들어간다.        
* 생성과 동시에 값을 넣어주지 않고 후에 넣어주었을 경우 `할당`이라고 부른다.    



**변수 초기화 :** 변수 선언과 동시에 값을 할당하는 작업으로 기본값이 들어가지 않는다.    
```java
int variable = 10;
variable = 20; // 할당도 가능하다.   
```  
* 4byte 만큼의 메모리가 할당된다.            
* 해당 메모리에 `variable` 이라는 이름이 붙는다.            
* 값을 초기화해주었으므로 변수 메모리 공간은 10을 저장한다.         
* 이 과정에서 메모리 어딘가에 10이 있으면 복사를 하고 없을 경우 새로 할당 후 넣는다.        
* 물론, 초기화 후에도 새로운 값을 할당하는 것도 가능하다.  

**상수 :** 변하지 않는 변수로 값을 한 번 넣으면 바꿀 수 없다.  
```java
final int START_NUMBER = 1;
final int END_NUMBER;
END_NUMBER = 9;

// START_NUMBER = 10;   --> ERROR!
// END_NUMBER = 99;     --> ERROR!
```
* `final` 키워드를 붙이면 변하지 않는 모듈이 된다.(변수, 클래스, 메서드등)       
* `final 변수`는 일반적인 변수와 달리 값을 한 번 넣으면 바꿀수 없고 컴파일 에러가 뜬다.       
* 단, 변수 선언시 초기화를 진행하지 않았다면 딱 1번의 할당은 인정을 해준다.     
* 물론, 값이 1번 들어간 후 할당을 진행하면 에러가 발생한다.    

# 변수의 스코프와 라이프타임
# 타입 변환, 캐스팅 그리고 타입 프로모션
# 1차 및 2차 배열 선언하기
# 타입 추론, var
# 라이브 강의
# 참고 
[oracle doc](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)
[프리미티브/레퍼런스 타입](https://weicomes.tistory.com/133)
