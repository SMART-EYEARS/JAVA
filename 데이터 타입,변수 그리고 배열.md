# 들어가면서 
> **목표 :** 자바의 프리미티브 타입, 변수 그리고 배열을 사용하는 방법을 익힙니다.

[1. 프리미티브 타입 종류와 값의 범위 그리고 기본 값](#프리미티브-타입-종류와-값의-범위-그리고-기본-값)   
[2. 프리미티브 타입과 레퍼런스 타입](#프리미티브-타입과-레퍼런스-타입)   
[3. 리터럴](#리터럴)   
[4. 변수 선언 및 초기화하는 방법](#변수-선언-및-초기화하는-방법)   
[5. 변수의 스코프와 라이프타임](#변수의-스코프와-라이프타임)   
[6. 타입 변환, 캐스팅 그리고 타입 프로모션](#타입-변환-캐스팅-그리고-타입-프로모션)   
[7. 1차 및 2차 배열 선언하기](#1차-및-2차-배열-선언하기)   
[8. 타입 추론, var](#타입-추론-var)  
[9. 라이브 강의](#라이브-강의)   
[10. 참고](#참고)   

# 프리미티브 타입 종류와 값의 범위 그리고 기본 값
> **프리미티브 타입 :** 사전에 정의 되어 있는 계산을 위한 실제 값을 저장하는 정적 데이터 타입이다.       
> 4가지 형태로 나뉘어졌으며 8개의 데이터 타입이 있다.  
   
**프리미티브 타입의 4가지 형태**               
|분류|설명|
|--|--|
|논리형|true/false 중 하나를 값으로 갖으며, 조건식과 논리적 계싼에 사용된다.|   
|문자형|문자를 저장하는데 사용되며, 변수에 하나의 문자만 저장할 수 있다.|    
|정수형|정수를 저장하는데 사용되며, 주로 int가 사용된다.<br>byte는 이진 데이터를 다룰 때 사용되며,<br>short은 C언어와의 호환을 위해 추가되었다.|    
|실수형|실수를 저장하는데 사용되며, 주로 double이 사용된다.|   
    
**프리미티브 타입의 크기와 범위 그리고 기본값**    
|데이터 타입|분류|크기|표현 가능 범위|기본값|
|----|-----|---|----------|-----|
|boolean|논리형|1 바이트|true, false|false|
|char|문자형|2 바이트|유니코드 문자|'\u0000'|
|byte|정수형|1바이트|-128 ~ 127|0|
|short|정수형|2바이트|-32,768 ~ 32,767|0|
|int|정수형|4바이트|-2,147,483,648 ~ 2,147,483,647|0|
|long|정수형|8바이트|-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807|0L|
|float|실수형|4바이트|+-(1.40 * 10 ^-45 ~ 3.40 * 10^38)|0.0f|
|double|실수형|8바이트|+-(4.94 * 10 ^-324 ~ 1.79 * 10^308)|0.0d|
       
* 변수를 생성할 때는 `int variable`과 같은 형식으로 선언해준다.       
* `boolean`을 제외한 나머지 7가지 타입은 서로 연산과 변환이 가능하다.    
* `char`는 문자 타입이지만 사실 [유니코드](https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C)와 매칭된 숫자를 저장한다.     
* `float`과 `double`은 정확한 값을 저장하는 것이 아닌 근사값을 저장하기애 다소 오차가 있다.         
* 단, 데이터 크기에 따라 `float은 6자리까지`, `double은 15자리까지`의 실수값을 보장한다.            
    
**기본값**
* 필드를 선언 했지만 **값을 할당하지 않았을 경우 미리 지정된 기본값이 들어간다.**      
* 정확히 말하면 초기화되지 않은 필드는 컴파일러에 의해 적절한 기본값이 할당된다.       
* 기본값은 일반적으로 데이터 유형에 따라 0 또는 null이 들어간다.           
* 그러나 이러한 기본값에 의존하는 것은 일반적으로 잘못된 프로그래밍 스타일이다.
* 때문에 기본값을 이용하는 것보다 값을 명시적으로 할당해주는 자세를 가지자.     
   
# 프리미티브 타입과 레퍼런스 타입
> 자료형은 프리미티브 / 레퍼런스 이 2가지 타입으로 나뉜다.          
 
**프리미티브 타입 :**    
* Access By Value
* 지정된 데이터 형식에 맞는 고정된 크기의 공간을 할당하고 **`데이터 값`** 을 저장한다.
* 변수 선언, 초기화, 할당시 값이 저장된 메모리 영역에 `직접적`으로 접근한다.
* 즉, 변수에 새 값이 할당 될 때 변수에 할당된 메모리 블럭에 저장된 값을 바로 변경한다는 뜻이다. 
* 변수와 데이터 값은 스택(Stack)영역에 저장된다.     
* 지정된 데이터 형식이 있기 때문에 **자료형**이라는 용어를 사용한다.  

**레퍼런스 타입 :**  
|타입|할당 메모리|기본값|
|---|--------|----|
|배열 (Array)|4 bytes (객체의 주소값)|Null|		
|열거 (Enumeration)|4 bytes (객체의 주소값)|Null|
|클래스 (Class)|4 bytes (객체의 주소값)|Null|
|인터페이스 (Interface)|4 bytes (객체의 주소값)|Null|
   
* Access By Reference
* `객체의 주소(4 byte 정수)`만큼 공간을 할당하고 `데이터 값`이 아닌 `메모리 주소`를 저장한다. 
* 변수에 저장된 메모리 주소를 참조하여 실제 대상을 조작하기에 레퍼런스 타입이라 부른다.      
* 레퍼런스 타입을 자료형으로 가진 변수의 이름도 `참조 변수`라고 부른다.    
* 변수는 스택(Stack)영역에 저장되지만 주소값을 통해 힙(Heap)으로 부터 데이터를 참조한다.
* 지정된 데이터 형식이 없기 때문에 **타입**이라는 용어를 사용한다.          
    
**비교**    
![데이터저장참조](https://user-images.githubusercontent.com/50267433/102764700-e7fe9300-43be-11eb-9ee4-f675a4fe9392.jpg)    
   


**String**    
* 사실 우리가 자주 사용하는 `String` 문자열 자료형도 레퍼런스 타입이다.      
* 하지만, 예외적으로 `java.lang.String` 문자열에 대한 특수 지원을 제공한다. 
* 예를 들면 문자열을 큰 따옴표로 묶으면 자동으로 새 String객체가 생성된다.
* `String str = "ABCDEFG";` 

# 리터럴

**리터럴의 타입**
* `Long`, `float`, `double` 같은 경우는 값 뒤에 접미사가 붙는다.
* `Long val = 10L;`, `float val = 10.01F;`, `double val = 10.001D;`
* 기본 리터럴 값이 `int`로 설정해두었기에 리터럴을 int 보다 큰 값으로 캐스팅하는 것이다.   
JVM 피연산자 스택이 피연산자를 4bye로 정의했기 때문에 



# 변수 선언 및 초기화하는 방법
# 변수의 스코프와 라이프타임
# 타입 변환, 캐스팅 그리고 타입 프로모션
# 1차 및 2차 배열 선언하기
# 타입 추론, var
# 라이브 강의
# 참고 
[oracle doc](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)
[프리미티브/레퍼런스 타입](https://weicomes.tistory.com/133)
