# 프로세스와 쓰레드  
**프로세스 :** OS로부터 작업을 할당받는 `'작업'`의 단위      
**쓰레드 :** 프로세스가 os로부터 할당받은 자원을 이용하는 `'실행'` 단위     
     
더 간략히 말하자면         
프로세스는 **실행중인 프로그램** 이고          
쓰레드는 **프로그램내에서 동작하는 여러 시스템**을 의미한다.           
          
이러한 프로세스와 쓰레드는 여러개가 존재할 수 있으며           
`멀티 프로세스(멀티 태스킹)` , `멀티 쓰레드`라고 말을 합니다.        

**멀티 프로세스** 같은 경우 어떤 프로세스가 종료되어도 독립적으로 실행되어 문제를 일으키지는 않지만       
각 프로세스마다 os 자원을 할당하여 사용하기에 cpu 처리와 메모리에 상당한 부담을 줍니다.        
  
**멀티 쓰레드** 같은 경우 하나의 프로세스내에 존재하는 자원을 모두가 공유하여 사용하므로 메모리 관리에 효율적이지만        
`Race Condition`이 발생될 수 있고 이를 해결하기 위해 `Synchronize` 를 사용해도 `DeadLock`을 조심해야 한다.            
또한 하나의 쓰레드에 문제가 생기면 모든 쓰레드가 중지되기에 이러한 점도 신경써야 한다.   

# 쓰레드 구현    
쓰레드를 구현하는 방법은 2가지가 있다.   
        
1. `Thread 클래스`를 상속       
2. `Runnable 인터페이스` 구현     
    
**Thread 클래스 상속**    
```java  
class MyThread extends Thread {
     
     @Override
     public void run(){/*작업 내용*/};

}
```

**Runnable 인터페이스 상속**    
```java  
class MyThread implements Runnable {
     
     @Override
     public void run(){/*작업 내용*/}
}
```       
___ 
    
참고로 **Runnable 인터페이스**는 run 메서드만 구현했기에      
해당 인터페이스를 사용할 경우 **람다로 대신 사용할 수 있다.**          
run 추상형 메서드는 매개변수랑 반환 값이 없는 메서드이다.      
         
**Runnable.interface**
```java
public interface Runnable{
  public void run();
}
```
   
**람다 구현**   
```java
        Runnable runnable = () -> System.out.println("Hello World");
```
      
## Thread 클래스와 Runnable 인터페이스 차이       
쉽게 말하면 Thread 클래스를 상속받아서 사용하면 해당 로직이 고정되지만             
Runnable 인터페이스를 여러개 만들어 놓아서 사용하면 필요에 따라                  
`new Thread(runnable).strat()` 형태로 바꾸어 가면서 사용할 수 있다.          
              
### 팁 - 스레드 이름 바꾸기             
```java           
new Thread(runnable) // 스레드 이름 - Thread-0     
new Thread(runnable, "스레드-0") // 스레드 이름 - 스레드-0    
```             
                       
### 팁 - 쓰레드 정보 얻어오기                       
Thread 클래스 상속시 자손 클래스에서 조상인 **Thread 클래스의 메서드를 직접 호출**할 수 있지만,                                   
Runnable을 구현했을시 Thread 를 상속받은것이 아니므로 **직접 호출할 수 없다.**                 
대신 `Thread.currentThread()` 를 통해 현재 실행중인 쓰레드 인스턴스를 반환받아 사용할 수 있다.      

**Thread 상속**
```java
class ThreadEx1 extends Thread {
     public void run(){
          System.out.println(getName());
     }
}
```
  
**Runnable 구현**     
```java
class ThreadEx2 implements Runnable {
     public void run(){
          System.out.println(Thread.currentThread().getName());
     }
}
```   
       
## 쓰레드의 실행            
우리는 쓰레드의 `run()` 메서드를 구현했지만 이를 직접 호출하지는 않는다.                     
사실은 **`start()`** 메서드가 **`run()`** 메서드를 호출하는 것이다.                  
      
**Thread 인스턴스 `start()`**
```java
ThreadEx t1 = new ThreadEx();
t1.start();
```
   
그리고 `start()`메서드를 호출했다고 해서 바로 실행되는 것이 아니라      
실행 대기 상태(`ReadyQueue`)에 있다가 자신의 차례가 되어야 실행된다.      
      
한 가지 더 알아 두어야 하는 것은 한 번 실행이 종료된 쓰레드는 다시 실행할 수 없다는 것이다.      
즉 **쓰레드는 자신의 일을 마치면 자동으로 소멸되기에 하나의 쓰레드에 대해 `start()` 한 번만 호출될 수 있다.**       
만일 한번더 실행하고 싶다면 아래와 같이 새롭게 인스턴스를 생성해서 `start()`를 실행해야 한다.     
    
**쓰레드 한번 더 실행하기**
```java
ThreadEx t1 = new ThreadEx();
t1.start();
t1 = new ThreadEx();
t1.start();
```

## 쓰레드 일시 중단 `sleep()`          
   
```java
     public static void sleep(long millis) throws InterruptedException  
```
`sleep()` 메서드는 인자로 전달된 값의 `millisecond` 만큼 해당 쓰레드의 실행을 일시적으로 멈춘다.        
`100` 의 값이 들어오면 `0.1초` 동안 일시 멈춤 후 다시 실행된다.          
   
```java
    public static void main(String[] args) {
        Runnable task1 = () -> {
            try {
                    for(int i=0; i < 20; i++){
                        if(i % 2 == 0) System.out.println(i + " ");
                        Thread.sleep(100);
                    }
                } catch (InterruptedException e) {
                e.printStackTrace();
            }
        };

        Thread t1 = new Thread(task1);
        t1.start();
    }
```
단일 쓰레드 환경으로 실행을 시켰기에 값은 일정한 순서대로 출력될 뿐이다.          
하지만 이렇게 현재 쓰레드를 잠시동안 일시 정지 후 다시 시작하게 할 수 있다.      
    
## 쓰레드의 동작.   

* 쓰레드가 하나 실행될 때 마다 호출스택 1개를 생성한다.   
* `main()`의 작업을 실행하는 것은 쓰레드이므로 호출스택 1개가 생성된다.   
* 생성된 호출 스택에는 `main()`이 할당되고 관련된 자원들도 할당 된다.   
* 만약 `main()`에서 다른 쓰레드를 생성하고 호출한다면 새로운 호출스택이 생성된다.   
* 해당 쓰레드에 관한 `run()` 이 할당되고 해당 메서드내의 자원들도 할당된다.     
      
## 멀티 쓰레드   
보통 쓰레드 하나에 CPU의 코어 하나가 할당되어 동시에 실행이 이뤄진다.        
**다면 과거 CPU 코어는 1개 였는데 어떻게 사용할 수 있었을까? 그리고 코어의 개수가 쓰레드보다 작으면?**      
     
CPU의 코어가 하나이던 시절 **멀티 쓰레드**를 이용하여 메모리를 효율적으로 사용할 수 있었다.      
      
1. CPU의 코어가 둘 이상인 것과 같은 효과를 보였다.       
2. 하나의 코어가 둘 이상의 쓰레드를 담당하므로 코어의 활용도가 높았다.         
     
코어가 하나이고 쓰레드가 둘 이상이면 이들은 코어를 나누어 차지하며 실행을 이어 나간다.       
그런데 그 나누는 시간의 조각이 매우 작기 때문에 동시에 실행되는 효과를 출분히 누릴 수 있었다.       
마찬가지로 멀티 코어 CPU 기반에서도 코어의 수보다 많은 수의 쓰레드가 생성되면 쓰레드들은 코어를 나누어 차지하게 된다.      

**멀티 쓰레드**
```java
    public static void main(String[] args) {
        Runnable task1 = () -> {
                for(int i=0; i < 20; i++){
                    if(i % 2 == 0) System.out.println(i + " ");
                }
        };

        Runnable task2 = () -> {
            for(int i=0; i < 20; i++){
                if(i % 2 == 1) System.out.println(i + " ");
            }
        };

        Thread t1 = new Thread(task1);
        Thread t2 = new Thread(task2);

        t1.start();
        t2.start();
        
    }
     // 0 1 3 5 7 9 11 2 13 15 17 19 4 6 8 10 12 14 16 18  
```

# 오후에 수정
