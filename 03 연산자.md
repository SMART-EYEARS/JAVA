# 들어가면서
> 자바가 제공하는 다양한 연산자를 학습하기   

[1. 연산의 기초](#연산의-기초)     
[2. 단항 연산자](#단항-연산자)     
[3. 산술 연산자](#산술-연산자)   
[4. 관계 연산자](#관계-연산자)       
[5. 논리 연산자](#논리-연산자)   
[6. 비트 연산자](#비트-연산자)    
[7. 비트 연산자](#비트-연산자)   
[8. 3항 연산자](#3항-연산자)   
[9. assignment(=) operator](#assignment-operator)   
[10. instanceof](#instanceof)  
[11. 화살표(->) 연산자](#화살표--연산자)   
[12. 연산자 우선 순위](#연산자-우선-순위)   
[13. Java 13, switch 연산자](#java-13-switch-연산자)   

# 연산의 기초  
> 연산에 대해서 공부하려면 연산의 정의를 알아야한다.    
     
연산이란 프로그램에서 데이터를 처리하여 결과를 산출하는 것이다.         
Java에서는 연산의 특징으로 피연산자간에 데이터가 일치해야 한다.          
그 과정에서 캐스팅, 프로모션과 같은 자료형 변환이 발생하기도 한다.     
[자료형 변환 내용은 해당 링크를 통해서 알아보자](https://github.com/kwj1270/TIL_JAVA/blob/master/02%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%ED%83%80%EC%9E%85%2C%EB%B3%80%EC%88%98%20%EA%B7%B8%EB%A6%AC%EA%B3%A0%20%EB%B0%B0%EC%97%B4.md#%ED%83%80%EC%9E%85-%EB%B3%80%ED%99%98-%EC%BA%90%EC%8A%A4%ED%8C%85-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%ED%83%80%EC%9E%85-%ED%94%84%EB%A1%9C%EB%AA%A8%EC%85%98)    
      
**연산 용어**
* **연산(operations) :**    
  * 프로그램에서 데이터를 처리하여 결과를 산출하는 것    
* **연산자(operator)**
  * 연산에서 사용되는 표시나 기호 `+, — , *, ==….`
* **피연산자(operand)**
  * 연산되는 데이터         
* **연산식(expression)**
  * 연산자와 피연산자를 이용하여 연산의 과정을 기술할 것 `x, y, z, i, j`

**프리미티브 타입과 래퍼 타입의 숫자 유형**  
* 연산자는 숫자 피연산자가 필요하며 숫자 결과를 생성한다.    
* 피연산자 유형은 `프리미티브 타입의 숫자 유형`이거나 `래퍼 타입의 숫자 유형`일 수 있다.   
* 프리미티브 타입 : `byte` , `short`, `char`, `int`, `long`, `float`, `double`     
* 래퍼 타입 : `Byte`, `Character`, `Short`, `Integer`, `Long`, `Float`, `Double`    
* 궁금증 : JVM 에서 두 피연산자간의 데이터 타입은 같아야 한다 했는데?     
* 정답 : 래퍼 클래스 타입은 연산시에 프리미티브 타입으로 언박싱되어 계산이 처리된다.       
즉, 프리미티브 타입으로 연산이 되는 것이고 이 과정에서 프로모션 우선 순위를 따른다.     

# 단항 연산자
> 피연산자 1개로 사용되는 연산자.   

|연산자|연산자의 기능|결합 방향|
|:---:|---------|:-----:|
|++, prefix|명령을 시작하기 전에 피연산자에 저장된 값을 증가<br>`val==++n;`|<-|
|++, postfix|명령이 끝난 후에 피연산자에 저장된 값을 증가<br>`val==n++;`|<-|
|--, prefix|명령이 시작하기 전에 피연산자에 저장된 값을 감소<br>`val==--n;`|<-|
|--, postfix|명령이 끝난 후에 피연산자에 저장된 값을 감소<br>`val==n--;`|<-|
|+|피연산자를 양수로 나타낸다.<br>대부분, 생략해서 사용한다.|x|
|-|피연산자를 음수로 나타낸다.|x|

```java
int a = 3;
System.out.println(++a);                     // 명령이 실행되기 전에 값이 4로 증가한다.
System.out.println(a);                       // 4출력 
System.out.println(a++);                     // 명령이 끝나고 출력되므로 4가 출력되고 증가됨
System.out.println(a);                       // 5가 출력된다.
System.out.println("");                      // 공백을 위한 빈칸.

a = 2;
int b = 4;
System.out.println(a++ == 2 && ++a == b);

// a는 현재 4이다.
System.out.println(a++ + ++a);


/* 실행 결과
 4
 4
 4
 5
 
 true
 10
 */
```
* 연산의 기준은 `코드 줄 단위`가 아닌 `연산 단위`이다.    
* `a++ == 2`같은 경우는 연산이 종료후 값이 증가되므로 true가 된다.   
* `++a == b`같은 경우는 `이전 후위 증가` + `전위 증가`로 값이 4가 되어 true가 된다.   
* `a++ + ++a`같은 경우는 전,후위가 같이 있으므로 둘다 5로 증가되어 계산되고 6으로 증가한다.    

# 산술 연산자
> **산술 연산자 :** 사칙 연산자(`+`, `-`, `*`, `/`)과 나머지(`%`) 연산자를 의미    

**산술 연산자**    
|연산자|연산자의 기능|결합 방향|
|:---:|---------|:-----:|
|**`+`**|두 피연산자의 값을 더한다.<br>`val = 4 + 3;`<br>값 : `7`|->|
|**`-`**|왼쪽의 피연산자 값에서 오른쪽의 피연산자 값을 뺀다<br>`val = 4 - 3;`<br>값 : `1`|->|
|**`*`**|두 피연산자의 값을 곱한다.<br>`val = 4 * 3;`<br>값 : `12`|->|
|**`/`**|왼쪽의 피연사 값을 오른쪽의 피연산자 값으로 나눈다.<br>`val = 4 / 3;`<br>값 : `1`|->|
|**`%`**|왼쪽의 피연산자 값을 오른쪽의 피연산자 값으로 나눴을 때 얻게 되는 나머지를 반환한다.<br>`val = 7 % 3;`<br>값 : `1`|->|

```java
int num1 = 8, num2 = 4;

System.out.println("+ 연산자에 의한 결과 : "+ (num1 + num2));
System.out.println("- 연산자에 의한 결과 : "+ (num1 - num2));
System.out.println("* 연산자에 의한 결과 : "+ (num1 * num2));
System.out.println("/ 연산자에 의한 결과 : "+ (num1 / num2));
System.out.println("% 연산자에 의한 결과 : "+ (num1 % num2));

/* 실행 결과

 + 연산자에 의한 결과 : 12
 - 연산자에 의한 결과 : 4
 * 연산자에 의한 결과 : 32
 / 연산자에 의한 결과 : 2
 % 연산자에 의한 결과 : 0
*/
```   
* 우리가 기존 아는 형태로 덧셈, 뺄셈, 나눗셈, 곱셈이 진행된다.         
* 또한, `나머지 연산 (%)`이 존재하여 나머지 값을 얻을 수 있다.             
* 나머지 연산은 헷갈리기 쉬운데 `7%2 == 1`처럼 몫을 구한 후의 나머지 값이다.        
* 이 외에도 사칙 연산을 진행할 때 오버플로우가 발생하는 것을 주의하면 좋다.

**복합 대입 연산자**
|연산자|연산자의 기능|결합 방향|
|:---:|---------|:-----:|
|**`+=`**|기존값과 피연산자값을 더하여 기존값을 갱신한다.<br>`int val =4;`<br>`val += 3;`<br>값 : `7`|->|
|**`-=`**|기존값에서 피연산자값을 빼서 기존값을 갱신한다.<br>`int val =4;`<br>`val -= 3;`<br>값 : `1`|->|
|**`*=`**|기존값과 피연산자값을 곱해서 기존값을 갱신한다.<br>`int val =4;`<br>`val *= 3;`<br>값 : `12`|->|
|**`/=`**|기존값을 피연산자값으로 나눈 몫으로 기존값을 갱신한다.<br>`int val =4;`<br>`val /= 3;`<br>값 : `1`|->|
|**`%=`**|기존값을 피연산자값으로 나눈 나머지로 기존값을 갱신한다.<br>`int val =7;`<br>`val /= 3;`<br>값 : `1`|->|

* 대입이 산술 연산자와 묶여서 정의된 형태의 연산자이다.   
* 변수의 값을 하나의 피연산자로 사용하고, 연산된 결과값을 다시 기존 변수에 대입하여 갱신한다.    
* 코드가 보다 간결해지는 장점이 있다.   

**특수값**   
|특수값|설명|
|--|--|
|Infinity|"무한"또는 INF 값은 너무 큰 숫자를 나타냅니다.<br>+INF 값은 너무 크고 양수 인 숫자를 나타냅니다.<br>-INF 값은 너무 크고 음수 인 숫자를 나타냅니다.<br>INF 값은 오버플로를 일으키는 부동 연산 또는 0으로 나누는 부동 소수점 연산에 의해 생성됩니다|
|NaN|"무기한"/ "숫자가 아님"또는 NaN은 의미없는 작업으로 인해 발생하는 값을 나타냅니다.<br>NaN 값은 0을 0으로 나누거나 0을 나머지로 계산하여 생성됩니다.|

|x|y|x / y|x % y|
|:-:|:-:|:-:|:-:|
|유한수|+-0.0|+-Infinity|NaN|
|유한수|+-Infinity|+-0.0|x|
|+-0.0|+-0.0|NaN|NaN|
|+-Infinity|유한수|+-Infinity|NaN|
|+-Infinity|+-Infinity|NaN|NaN|

```java
System.out.println(3/0);      // ArithmeticException Runtime Error!  
System.out.println(3/0.0);    // Infinity  
System.out.println(3.14/0);   // Infinity  

System.out.println(0/0);      // Nan  
System.out.println(10%0);     // Nan  
```
* `정수`를 `정수 0`으로 나누면 `ArithmeticException` 런타임 에러가 발생한다.   
* `정수`를 `실수 0.0`으로 나누거나 `실수`를 `정수 0`으로 나누면 `Infinity`가 나온다.    
* `정수 0`을 `0`으로 나누거나 `정수`를 `0`으로 나머지 계산을 하면 `NaN`이 나온다.        
    
# 관계 연산자
> **관계 연산자 :** 두 피연산자 사이에서 크기 및 동등 관계를 따져주는 이항 연산자이다.     
> 연산 결과값으로는 true/false를 나타내는 boolean 리터럴이 반환된다.    
   
|연산자|연산자의 기능|결합 방향|
|:--:|----------|:----:|
|`<`|왼쪽의 피연산자가 오른쪽의 피연산자보다 초과인지 묻는다<br>`1 < 2;`<br>결과 : `true`<br>`2 < 1;`<br>결과 : `false`|->|
|`>`|왼쪽의 피연산자가 오른쪽의 피연산자보다 초과인지 묻는다<br>`2 > 1;`<br>결과 : `true`<br>`1 > 2;`<br>결과 : `false`|->|
|`<=`|왼쪽의 피연산자가 오른쪽의 피연산자보다 이하인지 묻는다<br>`1 <= 2;`<br>결과 : `true`<br>`1 <= 1;`<br>결과 : `true`<br>`2 <= 1;`<br>결과 : `false`|->|
|`>=`|왼쪽의 피연산자가 오른쪽의 피연산자보다 이상인지 묻는다<br>`2 >= 1;`<br>결과 : `true`<br>`1 >= 1;`<br>결과 : `true`<br>`1 >= 2;`<br>결과 : `false`|->|
|`==`|두 피연산자의 값이 같은지 묻는다.<br>변수일 경우 메모리에 저장된 값이 동등한지 묻는다.<br>`1 == 1;`<br>결과 : `true`<br>`1 == 2;`<br>결과 : `false`|->|
|`!=`|두 피연산자의 값이 다른지 묻는다.<br>변수일 경우 메모리에 저장된 값이 다른지 묻는다.<br>`2 != 1;`<br>결과 : `true`<br>`1 != 1;`<br>결과 : `false`|->|



# 논리 연산자
# 비트 연산자
> **비트 연산자 :** 정수형인 피연산자를 비트 단위로 논리 연산을 진행하는 것   

**비트 연산자**   
   
|연산자|연산자의 기능|결합 방향|  
|:--:|----------|:-----:|  
|`&`|비트 단위로 AND 연산을 한다.<br>두 피연산의 비트값이 1일 경우 1리턴, 아닐 경우 0리턴<br>`n1 & n2`|->| 
|`₩`|비트 단위로 OR 연산을 한다.<br>두 피연산의 비트값중 하나라도 1일 경우 1리턴, 아닐 경우 0리턴<br>원래는 수직선 기호이지만, 마크다운 에러가 발생해서 `₩`으로 교체<br>`n1 ₩ n2`|->|  
|`^`|비트 단위로 XOR 연산을 한다.<br>두 피연산의 비트값이 하나라도 1일 경우 0리턴, 아닐 경우 1리턴<br>`n1 ^ n2`|->|    
|`~`|피연산자의 모든 비트를 반전시켜서 얻은 결과를 반환하며 단항이다.<br>1은 0으로, 0은 1로 치환한다.<br>`~n;`|<-|   

**`&`, `₩`, `^` 비트 연산 예시**      
   
|`x`|`y`|`x & y`|`x ₩ y`|`x ^ y`|
|:-:|:-:|:-:|:--:|:--:|
|1|1|1|1|0|
|1|0|0|1|1|
|0|1|0|1|1|
|0|0|0|0|0|

**`~`비트 연산 예시**    
   
|값|결과|
|-|-|
|0|1|
|1|0|


```java
System.out.println(30 & 20);
System.out.println(30 | 20);
System.out.println(30 ^ 20);
System.out.println(~30);
System.out.println(~20);
System.out.println('A' | 'B');
System.out.println(~'A');

/* 실핼 결과
 20
 30
 10
 -31
 67
 -66 
 */
```
* 비트는 0과 1로 이루어져있다.   
* 우리가 사용하는 모든 코드들은 비트로 되어 있다.   
* 정수 리터럴에 한하여 비트 연산을 진행할 수 있다.   
* 비트 연산을 진행할 경우 피 연산자들의 비트값 0과 1을 비교하여 계산한다.   
* 참고로, 문자 데이터 타입도 사실은 정수값이 들어가므로 비트 연산을 할 수 있다.   
* 단, 문자열은 불가능하다.   
    
<img width="856" alt="스크린샷 2020-12-23 오후 8 31 31" src="https://user-images.githubusercontent.com/50267433/102992307-56c62280-455e-11eb-8520-7c4c2a52bb0c.png">   
<img width="856" alt="스크린샷 2020-12-23 오후 8 39 25" src="https://user-images.githubusercontent.com/50267433/102992690-069b9000-455f-11eb-97c2-0bd9a87fb08a.png">   

* 각 칸은 `1bit`를 의미하며 총`8bit`, 즉 `1byte`로 구성되어 있다.     
* 편의를 위해 `int`의 `4byte` 메모리 전부를 표현하지 않고 `1byte`로 표현을 했다.   
* 30과 20의 비트를 기준으로 연산을 진행했다.      
* `&`, `₩`, `^`은 우리의 예상대로 계산이 진행되었다.        
* `~30`의 결과값으로는 `-31` 이 나왔다.               
* `~`는 0과1을 서로 치환하는 것이기에 원래는 값이 엄청 클 것이다.           
* 하지만, `~`를 사용할 경우 `-1*(피연산자값+1)`계산값이 나온다.             
* 이는 **정수의 표현 방법과 보수**로 인해 생기는 결과이며 올바른 계산법이다.                  
  
**보수**
* 컴퓨터가 정수를 표현하는 방식은 [MSB](https://ko.wikipedia.org/wiki/%EC%B5%9C%EC%83%81%EC%9C%84_%EB%B9%84%ED%8A%B8)에 따라 달라진다.     
* MSB가 0이면 양수
* MSB가 1이면 음수
* 하지만, 음수같은 경우 양수와 같은 방식으로 만들 경우 문제가 생긴다.
* 음수와 양수가 같은 방식일 경우 :
  *  1 : `00000001`
  * -1 : `10000001`
  * 1 + (-1) = `10000010` 이라는 이상한 값이 나온다.   
* **해결책 :** 정수의 비트값 0과 1을 뒤집은 다음 +1을 더해준다.      
1을 더해주는 이유는 치환된 비트끼리 값을 더할 경우 `11111111`이 되므로 1이 부족하다.  
  *  1 : `00000001`
  * -1 : `11111110` -> `11111111`
  * 1 + (-1) = `00000000` 이라는 정상적 계산 결과값이 나오게 되었다.       
# 시프트 연산 
# instanceof
# assignment(=) operator
# 화살표(->) 연산자
# 3항 연산자
# 연산자 우선 순위
# Java 13, switch 연산자
