# 컬렉션 프레임워크 
* 널리 알려진 자료구조와 알고리즘을 라이브러리 형태로 제공해주는 것          
* '컬렉션'이라는 이름을 사용한 이유는 데이터의 **저장 방법과 이에 관련된 알고리즘**을 중점으로 제공해주기 때문이다.        
* '라이브러리'라는 이름을 사용하지 않고 '프레임워크'를 사용한 것은 **자료구조와 알고리즘은 이미 그 구조가 있기 때문**          
     
![2630264F548D957F09](https://user-images.githubusercontent.com/50267433/93338124-f8a1e900-f864-11ea-93e5-df3405ba4b29.jpg)
     
* `Collection<E>` 인터페이스 - 선형
    * `List<E>` 
      * `ArrayList<E>`
      * `LinkedList<E>`
      * `Stack<E>`
      * `Vector<E>`
    * `Set<E>`
      * `HashSet<E>`
      * `TreeSet<E>`
      * `Queue<E>`   
    * `Queue<E>`
      * `PriorityQueue<E>`
    * `Deque<E>`
      * `ArrayDeque<E>`
* `Map<K,V>` 인터페이스 - 비선형
    * `HashMap<K,V>`
    * `HashTable<K,V>`
    * `ConcurrentHashMap<K,V>`


해당 클래스들은 구현한 인터페이스의 특징과 관련 메서드를 갖게된다.   

# List<E>
  
* `ArrayList<E>` : 메모리가 연속적인 데이터를 연결시킨 리스트         
* `LinkedList<E>` : 메모리가 불연속적인 데이터를 연결시킨 리스트         
* `Stack<E>` : LIFO 방식의 리스트, 즉 마지막 데이터가 최초 반환 데이터         
* `Vector<E>` : Synchronized 키워드를 사용해 멀티스레드시 동기화 가능한 리스트       
    
`List<E>` 인터페이스 구현 클래스들의 공통 특징       
1. 인스턴스 저장 순서를 유지한다.      
2. 동일한 인스턴스의 중복 저장을 허용한다.      

## 생성 
```java
        List<Integer> list = new ArrayList<>();
        List<Integer> list = new LikedList<>();
        List<Integer> list = new Stack<>();
        List<Integer> list = new Vector<>();
```
생성자의 인자값으로는 `크기` 또는 `Collection<E>를 구현한 객체`가 올 수 있다.   
   
```java
        List<Integer> list =  Arrays.asList(1,2,3,4,5);
        list = new ArrayList<>(list);
```
만일 배열을 넣어서 사용하고 싶으면 `Arrays.asList()`를 이용하면된다.  
`Arrays.asList()`는 가변인자를 가지고 있기 때문에 인자의 개수에 대해서 신경쓰지 않아도 되고   
리턴 값으로 `List<E>`데이터형으로(객체는 `ArrayList<E>`) 반환해주기에 이를 이용하여     
`List<E>` 인터페이스를 구현한 클래스 생성자의 인자로 넣어서 인스턴스를 초기화할 수 있다.  





## 생성 방법    
