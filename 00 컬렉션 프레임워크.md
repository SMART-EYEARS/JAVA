# 컬렉션 프레임워크 
* 널리 알려진 자료구조와 알고리즘을 라이브러리 형태로 제공해주는 것          
* '컬렉션'이라는 이름을 사용한 이유는 데이터의 **저장 방법과 이에 관련된 알고리즘**을 중점으로 제공해주기 때문이다.        
* '라이브러리'라는 이름을 사용하지 않고 '프레임워크'를 사용한 것은 **자료구조와 알고리즘은 이미 그 구조가 있기 때문**          
     
![2630264F548D957F09](https://user-images.githubusercontent.com/50267433/93338124-f8a1e900-f864-11ea-93e5-df3405ba4b29.jpg)
     
* `Collection<E>` 인터페이스 - 선형
    * `List<E>` 
      * `ArrayList<E>`
      * `LinkedList<E>`
      * `Stack<E>`
      * `Vector<E>`
    * `Set<E>`
      * `HashSet<E>`
      * `TreeSet<E>`
      * `Queue<E>`   
    * `Queue<E>`
      * `PriorityQueue<E>`
    * `Deque<E>`
      * `ArrayDeque<E>`
* `Map<K,V>` 인터페이스 - 비선형
    * `HashMap<K,V>`
    * `HashTable<K,V>`
    * `ConcurrentHashMap<K,V>`


해당 클래스들은 구현한 인터페이스의 특징과 관련 메서드를 갖게된다.     
`Collection<E>` 같은 경우 `Iterator<E>`를 상속받기 때문에 해당 메서드도 사용하여 순차적 접근을 도와준다.     
   
# `List<E>`
  
* `ArrayList<E>` : 메모리가 연속적인 데이터를 연결시킨 리스트         
* `LinkedList<E>` : 메모리가 불연속적인 데이터를 연결시킨 리스트         
* `Stack<E>` : LIFO 방식의 리스트, 즉 마지막 데이터가 최초 반환 데이터         
* `Vector<E>` : Synchronized 키워드를 사용해 멀티스레드시 동기화 가능한 리스트       
    
`List<E>` 인터페이스 구현 클래스들의 공통 특징       
1. 인스턴스 저장 순서를 유지한다.      
2. 동일한 인스턴스의 중복 저장을 허용한다.      

### 생성 
```java
        List<Integer> list = new ArrayList<>();
        List<Integer> list = new LikedList<>();
        List<Integer> list = new Stack<>();
        List<Integer> list = new Vector<>();
```
생성자의 인자값으로는 `크기` 또는 `Collection<E>를 구현한 객체`가 올 수 있다.   
   
```java
        List<Integer> list =  Arrays.asList(1,2,3,4,5);
        list = new ArrayList<>(list);
```
만일 배열을 넣어서 사용하고 싶으면 `Arrays.asList()`를 이용하면된다.  
`Arrays.asList()`는 가변인자를 가지고 있기 때문에 인자의 개수에 대해서 신경쓰지 않아도 되고   
리턴 값으로 `List<E>`데이터형으로(객체는 `ArrayList<E>`) 반환해주기에 이를 이용하여     
`List<E>` 인터페이스를 구현한 클래스 생성자의 인자로 넣어서 인스턴스를 초기화할 수 있다.  

### 데이터 추가/삭제
여기서 말하는 메서드는 인스턴스 내부에 존재하는 메서드로 `변수.메서드()`형태를 의미한다.   
   
|메서드명|역할|
|---|---|
|add(index/value)|리스트에 데이터를 넣는다/특정 인덱스에 값을 넣을수도 있음|
|remove(index/value)|헤더에 있는 데이터를 삭제/특정 인덱스의 값을 지울수도 있음|
|contains(value)|해당 값을 포함하는지 검사합니다.|   
|메서드All(value)|콜렉션 형태로 메서드를 처리하고 내부에 있는 데이터를 전부 활용한다|
|clear()|내부 값 초기화|   
|indexOf(value)|해당 값을 가진 인덱스를 반환|   
|sort(`Comparator<E>`)|내부 값 초기화|    

```java
```

### 사용 1 - FOR_EACH 
선형 구조이기 때문에 주로 FOR_EACH 문으로 이용하는 경우가 많다.     

```java
        List<Integer> list =  Arrays.asList(1,2,3,4,5);
        list = new ArrayList<>(list);
        
        for(Integer element : list){
            System.out.println(element);
        }
```

### 사용 2 - Iterator
순차적 접근을 도와주는 `Iterator`를 이용하는 방법은 아래와 같다.   
    
|메서드명|역할|
|---|---|
|hasNext()|다음 값이 있는지 Boolean 타입 반환|
|next()|다음 값 반환|
|remove()|현재값 지우기|
|forEachRemaining(Consumer<? extends E>)|각 요소마다 메서드 적용|  

   
```java

        List<Integer> list =  Arrays.asList(1,2,3,4,5);
        list = new ArrayList<>(list);

        Iterator<Integer> it = list.iterator();
        while (it.hasNext()){
            System.out.println(it.next());
        }
```
`Itrator<E> 변수 = 객체.Iterator();`를 통해 Itreator 참조 변수를 만들고        
`변수.hasNext()`를 통해 다음 값이 존재하는지 확인한다. -> Boolean          
`변수.next()`를 통해 다음 값을 반환한다.           
     
### 사용 3 - LinkedList에서만 사용할 수 있는 ListIterator       

|메서드명|역할|
|---|---|
|hasNext()|다음 값이 있는지 Boolean 타입 반환|
|next()|다음 값 반환|
|remove()|현재값 지우기|
|forEachRemaining(Consumer<? extends E>)|각 요소마다 메서드 적용|  
|hasPrevious()|이전 값이 있는지 Boolean 타입 확인|
|previous()|현재 값 반환하고 이전으로 이동|   

```java
        List<Integer> list =  Arrays.asList(1,2,3,4,5);
        list = new ArrayList<>(list);

        ListIterator<Integer> it = list.listIterator();
        
        while (it.hasNext()){it.next();}
        
        while (it.hasPrevious()){
            System.out.println(it.previous());
        }
     
```

# `Set<E>`   
      
`Set<E>` 인터페이스 구현 클래스들의 공통 특징         
1. 저장 순서가 유지되지 않는다.            
2. 데이터의 중복 저장을 허용하지 않는다.             
       
저장 순서가 유지되지 않으므로 List 처럼 데이터가 순차적으로 배치되지 않고, 중복 저장도 안된다.    

```java
import java.util.*;

class Num{
    private int num;
    public Num(int num) {this.num = num;}

    @Override
    public String toString() {
        return String.valueOf(num);
    }
}

public class SameTest {
    public static void main(String[] args) {
        HashSet<Num> set = new HashSet<>();
        set.add(new Num(7799));
        set.add(new Num(9955));
        set.add(new Num(7799));
        System.out.println("인스턴스 수: "+set.size());

        for(Num num : set){
            System.out.println(num.toString()+"\t");
        }
        System.out.println();
    }
}

// 결과 9955 7799 7799
```
    
하지만 위 코드를 보면 중복 저장은 안된다고 했는데 중복 저장이 되고 있다.        
**그렇다면 왜 중복이라 판단하지 않았으며 중복이라고 판단하는 기준이 무엇일까?**         
      
사실 동일한 값이라고 판단하는 기준은 **Object 클래스에 정의된 equals() 와 hashCode()를 기준으로 한다**          
해당 `hashCode()`를 이용하여 얻은 분류값과 `equals()`값이 true가 나올 경우 같다고 판단할 수 있다.      
  
```java
import java.util.*;

class Num{
    private int num;
    public Num(int num) {this.num = num;}

    @Override
    public String toString() {
        return String.valueOf(num);
    }

    @Override
    public int hashCode() {
        return num % 3;
    }

    @Override
    public boolean equals(Object o) {
        if (this.num == ((Num)o).num) return true;
        else return false;
    }
    
}

public class SameTest {
    public static void main(String[] args) {
        HashSet<Num> set = new HashSet<>();
        set.add(new Num(7799));
        set.add(new Num(9955));
        set.add(new Num(7799));
        System.out.println("인스턴스 수: "+set.size());

        for(Num num : set){
            System.out.println(num.toString()+"\t");
        }
        System.out.println();
    }
}

// 9955 7799
``` 

### `TreeSet<E>` 클래스의 이해와 활용   
트리 자료구조를 기반을 인스턴스를 저장한다.         
이는 정렬된 상태가 유지되면서 인스턴스가 저장됨을 의미한다.         
    
즉, 중복은 허용하지 않되 정렬 상태를 유지시켜주는 클래스입니다.      
    
* 데이터의 중복을 허가하지 않는다.        
* 데이터를 정렬 기준에 맞춰서 정렬한다.       

데이터의 중복을 피하기 위해 같음의 기준을 `hashcode()` 와 `equals()` 를 통해 설정했습니다.        
그리고 일반적인 수의 경우 그 크기를 기준으로 정렬이 되지만 클래스의 정렬의 기준은 무엇일까요?               
           
**기준 클래스**
```java

```




