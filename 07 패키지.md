# 들어가면서
> **목표 :** 자바의 패키지에 대해 학습하세요.
   
[1. package 키워드](#package-키워드)    
[2. import 키워드](#import-키워드)    
[3. 클래스패스](#클래스패스)         
[4. CLASSPATH 환경변수](#classpath-환경변수)       
[5. -classpath 옵션](#-classpath-옵션)    
[6. 접근지시자](#접근지시자)    
   
# package 키워드
package는 관련 클래스를 그룹화하는데 사용되며 파일 디렉터리의 폴더로 생각해도 좋다.   
우리는 '이름 충돌'을 피하기 위해 패키지를 사용하고 더 나은 유지 보수가 가능한 코드를 작성한다. 

**package 키워드의 특징**
1. 하나의 소스파일에는 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용한다.   
2. 모든 클래스는 반드시 하나의 패키지에 속해야 한다.  
3. 패키지는 점`(.)`을 구분자로 하여 계층구조로 구성할 수 있다.   
4. 패키지는 물리적으로 클래스 파일`(.class)`을 포함하는 하나의 디렉터리이다.   
5. 패키지의 첫 이름을 `java`로 시작하면 안된다.(내장 패키지와 섞이므로 금지시킨 것이다.)    
6. 패키지의 이름으로 자바 예약어를 사용하면 안 된다.       
7. `cmd/terminal` 에서의 Java 명령어들은 가장 상위 루트에서 진행해야한다.         
특정 경로에서 직접 컴파일 하면 상위 경로에 있는 의존된 다른 클래스들을 불러오기 힘들어진다.          
가장 상위 루트에서 컴파일하면 어느 하위 경로의 클래스든 불러올 수 있기에 이렇게 사용한다.   
    
**FQCN(Fully Qualified Class Name)**  
```java
class Main {
    public static void main(String[] args) {
        String str = new String("일반 호출"); 
        java.lang.String str2 = new java.lang.String("FQCN 호출");
        // java.lang.String 이 FQCN이다.   
    }
}
``` 
* `패키지 경로`+`클래스 이름`           
* 클래스를 포함한 패키지와 클래스 이름을 모두 포함한 것을 의미한다.           
* 필자의 경험으로는 `applicationContext`에서 주로 사용했다.          
* 어떤 상황에서는 `FQCN`에 파일의 확장자까지 요구하는 경우도 있다.     
   
**자바 패키지의 장점**   
1. 클래스와 인터페이스를 분류하여 유지 관리 보수를 쉽게 할 수 있다.
2. 액세스 보호를 제공하여 패키지로 그룹된 클래스 사용을 우선시한다.             
3. 외부 패키지와 동일한 이름을 가진 클래스의 이름 충돌을 제거한다.       
      
**패키지는 2가지 범주로 나뉜다.**     
* Built-in Package
* User-defined Packages 
    
## Built-in Package        
> Java의 내장 패키지로 Java API에 존재하는 클래스의 패키지를 의미한다.       
> `java`, `lang`, `awt`, `javax`, `swing`, `net`, `io`, `util`, `sql` 등이 존재한다.   
     
Java API는 자바 개발 환경에 필요한 클래스 라이브러리를 무료로 제공한다.             
라이브러리에는 입력, 데이터베이스 프로그래밍 등을 관리하기 위한 구성 요소가 포함되어 있다.        
    
```java
import java.io.*
import java.sql.*;
import javax.xml.*
import org.w3c.*
import com.sun.*
...               // 등등 
```   
* `Built-in Pacakage`를 전부 소개하고 싶지만 그 수가 많기에 생략한다.               
* 대신 패키지 이름과 관련된 내용에 대해서 서술해보겠다.      
* 전체 목록은 [Oracles 웹 사이트](https://docs.oracle.com/javase/8/docs/api/)에서 찾을 수 있다.    
   
**Built-in Package의 시작이름 해설**    
   
|패키지 시작 이름|내용|
|------------|---|
|java|Java 런타임 환경(JRE)을 활성화하거나 구성하는 클래스 모음(Java vendor 개발)|
|javax|기본 java 패키지를 보완하기 위한 자바 확장 패키지(Java vendor 개발)|
|org|써드파티의 패키지 - 일반적으로 비영리단체(오픈소스)의 패키지|
|com|써드파티의 패키지 - 일반적으로 영리단체(회사)의 패키지|
    

## 사용자 정의 패키지  
> Built-in 외에도 소프트웨어를 제작하는데 필요한 패키지를 사용자가 직접 정의하는 것    
    
사용자 정의 패키지는 같은 이름의 패키지를 피하기 위해 몇 가지 명명 규칙을 따른다.    
  
* 패키지 이름을 모두 소문자로 정의한다.
* 패키지 이름은 마침표로 구분된다.
* 이름은 이름을 만든 회사 또는 조직에 의해 결정된다.

사실, 이는 사용자 정의 패키지에 국한된 것이 아닌 모든 패키지에 적용된다.      
하지만 실질적으로 우리가 직접 관여할 수 있는 부분은 사용자 정의 패키지이다.        
그렇기 때문에 이 같은 주의사항을 이 부분에 넣었다.            
             
당연한 사실이지만, **디렉터리 구조와 패키지 이름의 구조는 동일하게 해야한다.**        
대부분의 IDE에서는 소스파일을 생성하면 디렉터리와 일치하는 패키지를 자동으로 기술해준다.      
그러므로 우리는 구상하고자 하는 패키지대로 디렉터리를 구성해주면 된다.            
           
조직을 기반으로 패키지 이름을 결정하기 위해 일반적으로 회사 URL을 반대로 시작한다.     
그 후, 이름 지정 규칙은 회사에서 정의하고 부서 이름과 프로젝트 이름을 포함 할 수 있다.   
예를 들어, 배달의 민족 정산시스템 팀을 기준으로 패키지를 만들면 다음과 같다.        
    
```java
package com.baemin;  // 배달의 민족 URL : https://www.baemin.com/
```
* 조직을 기반으로 패키지 이름을 결정하기 위해 일반적으로 회사 URL을 반대로 시작한다.   

```java
package com.baemin.calculate;  // 배달의 민족 URL : https://www.baemin.com/
```   
* 그 후, 이름 지정 규칙은 회사에서 정의하고 부서 이름과 프로젝트 이름을 포함 할 수 있다.        

이러한 규칙을 따르게 된다면 각 부서별로 작성된 프로그램을 통합할 때             
`디렉터리 충돌`, `패키지 충돌`이 발생할 가능성이 줄어들며             
지정된 상위 패키지를 공통으로 사용한다는 특징이 있어 병합하기에 편리해진다.          

**unnamed package**    
```java
public class Sample {
    public static void main(String[] args) {
        System.out.println("Hello World!");     
    }
}
```
간혹, package를 기술하지 않아도 코드가 동작하기도 한다.           
모든 클래스는 반드시 하나의 패키지에 속해야 한다는 특징과 모순된다.     
그럼에도 불구하고 패키지를 선언하지 않고도 아무런 문제가 없었던 이유는   
자바에서 기본적으로 제공하는 `이름없는 패키지(unnamed package)`가 있기 때문이다.  
소스파일에 자신이 속할 패키지를 지정하지 않은 클래스는 자동적으로 이름없는 패키지에 속한다.   
결국 패키지를 지정하지 않는 모든 클래스들은 같은 패키지에 속하는 셈이된다.   
    

**cmd/terminal 에서의 패키지 사용법**     
```java
package com.javachobo.book;

class PackageTest {
    public static void main (String[] args) {
        System.out.println("Hello World!");     
    }  
}
```
```cmd
C:\jdk1.8\work>javac -d . PackageTest.java
```
* `javac` 컴파일에서 `-d` 옵션을 추가하여 컴파일을 할 수 있다.   
* `-d` 옵션은 소스파일에 지정된 경로르 통해 패키지의 위치를 찾아서 클래스파일을 생성한다.   
* 만일 지정된 패키지와 일치하는 디렉터리가 없는 경우 **디렉터리를 자동으로 생성한다.**    
* `-d` 옵션 뒤에는 해당 패키지의 루트 디렉터리의 경로를 적어준다.     
* IDE를 사용한 것이 아니기에 패키지의 루트 디렉터리를 `CLASSPATH`에 포함시켜야한다.       
* 루트 디렉터리를 `CLASSPATH`에 포함시켜야 `JVM`이 `PackageTest`클래스를 찾을 수 있다.     
                
# import 키워드       
> 자바 컴파일러에 코드에서 사용할 클래스의 패키지에 대한 정보를 미리 제공하는 역할         
      
외부 패키지를 액세스하는 방법에는 3 가지가 있다.      
   
1. `import package. *;` 
2. `import package.classname;`
3. `FQCN`    

   
**FQCN**    
```java
class Main {
    public static void main(String[] args) {
        java.lang.String str = new java.lang.String("FQCN 호출");
        java.util.ArrayList<java.lang.String> stringArrayList = 
            new java.util.ArrayList<>();
        java.util.LinkedList<String> stringLinkedList = 
            new java.util.LinkedList<>();
    }
}
```
소스코드를 작성할 때 다른 패키지의 클래스를 사용하려면            
패키지명이 포함된 클래스 이름, 즉 `FQCN`을 매번 기술해야한다.     
하지만, 이러한 작업을 반복하는 것은 불편한 것은 물론 코드의 가독성을 매우 떨어뜨린다.   
이러한 문제점을 해결하기 위해 자바에서는 `import`문을 지원한다.        

**import 문(클래스 지정)**
```java
import java.util.ArrayList;
import java.util.LinkedList;

class Main {
    public static void main(String[] args) {
        String str = new String("FQCN 호출");
        ArrayList<String> stringArrayList = new ArrayList<>();
        LinkedList<String> stringLinkedList = new LinkedList<>();
    }
}
```
* `import` 문은 코드를 작성하기 전에 사용하고자 하는 클래스를 로드한다.          
* `import` 문으로 코드를 미리 로드하면 `FQCN`을 굳이 기술하지 않아도 된다.   

**import 문`(*)`**
```java
import java.util.*;

class Main {
    public static void main(String[] args) {
        String str = new String("FQCN 호출");
        ArrayList<String> stringArrayList = new ArrayList<>();
        LinkedList<String> stringLinkedList = new LinkedList<>();
        
        List<String> stringList = new LinkedList<>();
        Set<String> stringSet = new HashSet<>();
        Map<String, Integer> stringIntegerMap = new HashMap<>();
    }
}
```     
* `*`를 사용하면 지정된 클래스가 아닌 라이브러리 자체를 가져온다.            
* 즉, 지정된 디렉터리 및 하위 디렉터리에 존재하는 모든 클래스를 가져온다.       

**클래스 이름이 충돌되는 경우**
```java
import com.sun.javafx.util.Logging;
    
class Main {
    public static void main(String[] args) {
        
        Logging logging0; // com.sun.javafx.util의 로깅
        com.sun.javafx.binding.Logging logging1;
        com.sun.javafx.scene.control.Logging logging2;
    }
}
```
* 단, 동일한 명의 클래스가 존재하고 이를 사용할 경우           
* `import`문으로 로드한 클래스외에는 `FQCN`을 기술해야 충돌이 일어나지 않는다.      
     
**static import 문**     
```java
import static java.lang.Integer.*;     // Integer의 모든 static 구성 요소    
import static java.lang.System.out;    // System의 static 참조변수인 out 참조변수   
import static java.lang.Math.PI;       // Math의 static 일반변수인 PI 변수(double 상수)
import static java.lang.Math.random;   // Math static 메서드인 random 메서드, ()는 붙이지 않는다.    
   
// test 에서 주로 assert에 관련해서 사용한다.    
import static org.assertj.core.api.Assertions.assertThat;

class Main {
    public static void main(String[] args) {
        out.println(random() + PI + MIN_VALUE);
        // out : java.lang.System의 클래스 참조변수
        // random : java.lang.Math의 클래스 메서드
        // PI : java.lang.Math의 클래스 변수
        // MIN_VALUE : java.lang.Integer의 클래스 변수 
    }
}

```
* `import` 에는 `static` 키워드를 붙일 수 있다.            
* 이를 **static import 문이라고 부른다.**           
* 특정 클래스의 `static`멤버(변수,메서드)를 자주 사용할 때 편리하다.          


**import를 사용하지 않아도 되는 경우**
```java
// import java.lang.*

class ImClass{}
class Main {
    public static void main(String[] args) {
        String name = new String("김우재");
        ImClass imClass = new ImClass(); 
    }
}
```  
* `java.lang` 같은 경우는 Java 에서 미리 import 해놓았다.            
* 즉, 사용자가 직접 `import` 하지 않아도 `java.lang` 클래스를 사용할 수 있다.          
* 이유로는 `java.lang` 같은 경우 자주 사용되는 클래스들이 모여있기 때문이다.           
* 같은 소스 파일 또는 패키지에 있는 클래스는 `import`와 `FQCN`을 붙이지 않아도 된다.       
* `import`와 `FQCN`를 생략할 경우 동일 패키지를 기준으로 클래스를 찾기 때문이다.      
   
# 클래스패스          
> **클래스패스 :** JVM이 프로그램을 실행할 때, 클래스파일을 찾는 데 기준이 되는 파일 경로      
   

# CLASSPATH 환경변수
# -classpath 옵션
# 접근지시자
# 참고
[w3School package](https://www.w3schools.com/java/java_packages.asp)
