# 들어가면서   
> 목표 : 자바의 멀티쓰레드 프로그래밍에 대해 학습하세요.    

# 프로세스와 쓰레드
프로세스는 운영체제로부터 자원을 할당받는 **작업의 단위**이다.         
쓰레드는 프로세스가 할당 받은 자원을 이용하는 **실행 단위**이다.     
      
![01AEC5FD-FDBA-46FE-8DC5-AC667A9AF33E](https://user-images.githubusercontent.com/50267433/105000222-69eee400-5a71-11eb-96ed-e3b4fc81802f.png)       
사진 출처 : [워크맨](https://www.youtube.com/channel/UCwx6n_4OcLgzAGdty0RWCoA)
         
비유 하자면 야구장에서 맥주를 파는 사업을 프로세스라 하고          
본사로부터 맥주를 할당 받아서 판매하는 사람이 쓰레드이다.           
        
![40850_76494_06](https://user-images.githubusercontent.com/50267433/105001975-eb477600-5a73-11eb-85fc-3d9e4f29b563.jpg)       
사진 출처 : [워크맨](https://www.youtube.com/channel/UCwx6n_4OcLgzAGdty0RWCoA)      
     
여기서 맥주 사업 말고 치킨 사업까지 같이 할 경우 이를 멀티 태스킹, 멀티 프로세스라 말하고             
맥주를 할당 받아서 판매하는 사람이 여러명일 경우 이를 멀티 쓰레드라고 말할 수 있다.               
                       
우리가 실행하는 **자바 애플리케이션**은 하나의 프로세스이다.              
애플리케이션 내에서 실행되는 **작업**은 하나의 쓰레드이다.              
그리고 애플리케이션 내에서 작업을 여러개 실행할 경우 이는 멀티 쓰레드가 된다.           
           
# Thread 클래스와 Runnable 인터페이스     
자바에서 쓰레드를 구현할 수 있는 방법은 2가지이다.   

1. Thread 클래스를 상속하여 구현하는 방법        
2. Runnable 인터페이스를 구현하고 Thread에 주입하는 방법     
  
## Thread 클래스    
**Thread 클래스**      
```java
class Thread implements Runnable {
    ...     // 생략
    
    private void init(ThreadGroup g, Runnable target, String name,
                      long stackSize) {
        init(g, target, name, stackSize, null, true);
    }
    
    public Thread(Runnable target) {
        init(null, target, "Thread-" + nextThreadNum(), 0);
    }
        
    /* What will be run. */
    private Runnable target;
        
    @Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }
    
    ...     // 생략
}
```

* `Thread` 클래스는 정의된 클래스로 `Runnable` 인터페이스를 구현한다.                     
* 당연한 얘기이겠지만, Thread와 관련된 변수 및 상수 그리고 메서드를 제공한다.          
* `Runnable` 인터페이스를 구현하기에 `run()` 메서드가 실제로 정의되어 있는 모습이다.      
* 하지만, `run()` 메서드는 Runnable 인터페이스를 구현한 구현체의 `run()`메서드를 실행만 한다.   
* 즉, 개발자가 Runnable 인터페이스의 구현체를 생성자나 `init()`을  통해 주입시켜줘야 한다.     
          
**Thread 클래스를 상속하여 구현하는 방법**
```java
class MyThread extends Thread {
    
    @Override 
    public void run() {
        /* 작업 내용 */
    }      
}
```
앞선 코드에서 보았듯이 Thread 클래스는 의존하는 구현체의 run()을 실행한다.           
그렇기에 상속을 이용한 쓰레드를 구현하고자 한다면               
사용자가 직접 `run()` 메서드를 오바리이딩해서 구현해야한다.                

## Runnable 인터페이스     
**Runnable 인터페이스**         
```java
@FunctionalInterface
public interface Runnable {
    public abstract void run();
}
```
* `Runnable` 인터페이스는 `run()`메서드만을 가지고 있는 함수형 인터페이스다.      
* 클래스에서 `Runnable` 인터페이스를 구현해서 `run()` 정의하고 사용해야한다.     
    
**2. Runnable 인터페이스를 구현하고 Thread에 주입하는 방법**   
```java
class MyRun implements Runnable {
    @Override 
    public void run() {
        /* 작업 내용 */
    }  
}

class Sample {
     public static void main(String[] args) {
         Thread thread = new Thread(new MyRun());
     }
}
```
`Runnable` 인터페이스를 구현했다고 해서 쓰레드가 생성되는 것은 아니다.      
`Runnable` 인터페이스 구현체를 Thread 클래스에 생성자를 통해 주입하고    
`Thread` 클래스를 이용해서 쓰레드를 실행해야 한다.  

```java
class Sample {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> System.out.println("작업 내용"));
    }
}
```
`Runnable` 인터페이스는 함수형 인터페이스이기에 람다식을 사용할 수 있다.       
     
## Thread VS Runnable    
결론부터 말하자면 `Runnable` 인터페이스를 구현하는 것이 주로 선호되는 방법이다.   
   
```java   
class MyThread extends Thread {     // 상속을 추가로 못하게 된다.    
    
    @Override 
    public void run() {
        /* 작업 내용 */
    }      
}
```

Runnable을 구현하면 클래스가 유연해진다.   
자바는 단일 상속만 지원하므로 하나의 클래스만 상속할 수 있다.                         
Thread 클래스를 상속받아 `run()`을 구현한 클래스는 더 이상 상속 받을 수 없다.  

```java
class MyRun implements Runnable {
    @Override 
    public void run() {
        /* 작업 내용 */
    }  
}

class MyRun2 implements Runnable {
    @Override 
    public void run() {
        /* 작업 내용 */
    }  
}

class Sample {
     public static void main(String[] args) {
         Thread thread = new Thread(new MyRun());
         thread = new Thread(new MyRun2());           // 작업 교체  
     }
}
```
또한, Thread 상속받아 구횬하면 수행하려는 작업은 항상 스레드내에만 존재하게된다.       
그러나 Runnable을 구현하는 경우 다양한 Thread 클래스에서 사용할 수 있다.     
그렇기 때문에, 상속에 자유로운 Runnable 인터페이스를 구현하는 것을 선호한다.           

```java
class MyRun implements Runnable {
    @Override 
    public void run() {
        /* 작업 내용 */
    }  
}

class Sample {
     public static void main(String[] args) {
         Thread thread = new Thread(new MyRun());
     }
}
```
또한, 인터페이스로 구현하면 실행 코드와 쓰레드 구현을 명확하게 구분할 수 있다.     


# 쓰레드의 상태
# 쓰레드의 우선순위
# Main 쓰레드
# 쓰레드의 동기화
멀티 쓰레드의 경우,            
여러 쓰레드가 동일한 프로세스 내의 자원을 공유해서 사용하기 때문에              
`Race Condition`과 같이 쓰레드간의 작업에 영향을 줄 수 있다.          
즉, 원래 의도했던 결과가 아닌 **엉뚱하고 치명적인 결과를 불러일으킬 수 있다.**   
      
이러한 문제를 발생시키지 않기 위해서는         
특정 작업을 끝마치기 전까지 다른 쓰레드에 의해 방해받지 않도록 하는 것이 필요하다.        
그래서 도입된 개념이 바로 **임계영역(critical section)** 과 **잠금(lock)** 이다.      


![3](https://user-images.githubusercontent.com/50267433/105040691-7f7e0100-5aa5-11eb-93f5-e3292066f577.PNG)      

![2](https://user-images.githubusercontent.com/50267433/105040729-8c025980-5aa5-11eb-8ef4-908dbc1272f0.PNG)   

![3](https://user-images.githubusercontent.com/50267433/105040691-7f7e0100-5aa5-11eb-93f5-e3292066f577.PNG)      

![4](https://user-images.githubusercontent.com/50267433/105040757-94f32b00-5aa5-11eb-9e2c-94edf9c32578.PNG)   
      
공유 데이터를 사용하는 코드 영역을 임계 영역으로 지정해놓고,              
공유 데이터가 가지고 있는 `lock`을 획득한 하나의 쓰레드만 코드를 수행할 수 있게 한다.         
그리고 해당 쓰레드가 임계 영역 내의 모든 코드를 수행하고 벗어나서 lock을 반납해야만       
다른 쓰레드가 반납된 lock을 획득하여 임계 영역의 코드를 수행할 수 있게 된다.    








# 데드락

