# 들어가면서   
> 목표 : 자바의 멀티쓰레드 프로그래밍에 대해 학습하세요.    

# 프로세스와 쓰레드
프로세스는 운영체제로부터 자원을 할당받는 **작업의 단위**이다.         
쓰레드는 프로세스가 할당 받은 자원을 이용하는 **실행 단위**이다.     
      
![01AEC5FD-FDBA-46FE-8DC5-AC667A9AF33E](https://user-images.githubusercontent.com/50267433/105000222-69eee400-5a71-11eb-96ed-e3b4fc81802f.png)       
사진 출처 : [워크맨](https://www.youtube.com/channel/UCwx6n_4OcLgzAGdty0RWCoA)
     
     
비유 하자면 야구장에서 맥주를 파는 사업을 프로세스라 하고          
본사로부터 맥주를 할당 받아서 판매하는 사람이 쓰레드이다.           
        
![40850_76494_06](https://user-images.githubusercontent.com/50267433/105001975-eb477600-5a73-11eb-85fc-3d9e4f29b563.jpg)       
사진 출처 : [워크맨](https://www.youtube.com/channel/UCwx6n_4OcLgzAGdty0RWCoA)      
     
여기서 맥주 사업 말고 치킨 사업까지 같이 할 경우 이를 멀티 태스킹, 멀티 프로세스라 말하고             
맥주를 할당 받아서 판매하는 사람이 여러명일 경우 이를 멀티 쓰레드라고 말할 수 있다.               
                       
우리가 실행하는 **자바 애플리케이션**은 하나의 프로세스이다.              
애플리케이션 내에서 실행되는 **작업**은 하나의 쓰레드이다.              
그리고 애플리케이션 내에서 작업을 여러개 실행할 경우 이는 멀티 쓰레드가 된다.           
           
프로세스와 쓰레드를 깊게 설명하는 것은 문맥을 어지럽힐 가능성이 커서       
더 자세히 공부하고 싶으신 분들을 위해 URL을 남기겠다. [url](#)      
   
# Thread 클래스와 Runnable 인터페이스     
자바에서 쓰레드를 구현할 수 있는 방법은 2가지이다.   

1. Thread 클래스를 상속하여 구현하는 방법        
2. Runnable 인터페이스를 구현하고 Thread에 주입하는 방법     
  
## Thread 클래스    
**Thread 클래스**      
```java
class Thread implements Runnable {
    ...     // 생략
    
    private void init(ThreadGroup g, Runnable target, String name,
                      long stackSize) {
        init(g, target, name, stackSize, null, true);
    }
    
    public Thread(Runnable target) {
        init(null, target, "Thread-" + nextThreadNum(), 0);
    }
        
    /* What will be run. */
    private Runnable target;
        
    @Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }
    
    ...     // 생략
}
```

* `Thread` 클래스는 정의된 클래스로 `Runnable` 인터페이스를 구현한다.                     
* 당연한 얘기이겠지만, Thread와 관련된 변수 및 상수 그리고 메서드를 제공한다.          
* `Runnable` 인터페이스를 구현하기에 `run()` 메서드가 실제로 정의되어 있는 모습이다.      
* 하지만, `run()` 메서드는 Runnable 인터페이스를 구현한 구현체의 `run()`메서드를 실행만 한다.   
* 즉, 개발자가 Runnable 인터페이스의 구현체를 생성자나 `init()`을  통해 주입시켜줘야 한다.     
          
**Thread 클래스를 상속하여 구현하는 방법**
```java
class MyThread extends Thread {
    
    @Override 
    public void run() {
        /* 작업 내용 */
    }      
}
```
앞선 코드에서 보았듯이 Thread 클래스는 의존하는 구현체의 run()을 실행한다.           
그렇기에 상속을 이용한 쓰레드를 구현하고자 한다면               
사용자가 직접 `run()` 메서드를 오바리이딩해서 구현해야한다.                

## Runnable 인터페이스     
**Runnable 인터페이스**         
```java
@FunctionalInterface
public interface Runnable {
    public abstract void run();
}
```
* `Runnable` 인터페이스는 `run()`메서드만을 가지고 있는 함수형 인터페이스다.      
* 클래스에서 `Runnable` 인터페이스를 구현해서 `run()` 정의하고 사용해야한다.     
    
**2. Runnable 인터페이스를 구현하고 Thread에 주입하는 방법**   
```java
class MyRun implements Runnable {
    @Override 
    public void run() {
        /* 작업 내용 */
    }  
}

class Sample {
     public static void main(String[] args) {
         Thread thread = new Thread(new MyRun());
     }
}
```
`Runnable` 인터페이스를 구현했다고 해서 쓰레드가 생성되는 것은 아니다.      
`Runnable` 인터페이스 구현체를 Thread 클래스에 생성자를 통해 주입하고    
`Thread` 클래스를 이용해서 쓰레드를 실행해야 한다.  

```java
class Sample {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> System.out.println("작업 내용"));
    }
}
```
`Runnable` 인터페이스는 함수형 인터페이스이기에 람다식을 사용할 수 있다.       
     
## Thread VS Runnable    





# 쓰레드의 상태
# 쓰레드의 우선순위
# Main 쓰레드
# 동기화
# 데드락

# 
**`Thread` 클래스 :** 쓰레드를 생성 및 
**`Runnable` 인터페이스 :** 쓰레드를 생성 및 

**Thread 클래스와 Runnable 인터페이스의 차이점**

Runnable 인터페이스를 구현하는 것이 선호되는 방법입니다. 


1. 여기서는 스레드의 동작을 실제로 전문화하거나 수정하는 것이 아닙니다. 
스레드에 실행할 무언가를 제공하고 있습니다. 
즉, 구성이 더 나은 방법입니다.

1. Java는 단일 상속만 지원하므로 하나의 클래스만 확장 할 수 있습니다.
2. 인터페이스를 인스턴스화하면 코드와 스레드 구현을 더 명확하게 구분할 수 있습니다.

구현 Runnable하면 수업이 더 유연 해집니다. 확장 Thread하면 수행중인 작업은 항상 스레드에있게됩니다. 
그러나 구현 Runnable하는 경우 반드시 그럴 필요는 없습니다. 
스레드에서 실행하거나 일종의 실행기 서비스에 전달하거나 단일 스레드 애플리케이션 내에서 작업으로 전달할 수 있습니다.
JDK 4 이하에서 작업하는 경우 버그가 있습니다.
http://bugs.java.com/bugdatabase/view_bug.do;jsessionid=5869e03fee226ffffffffc40d4fa881a86e3:WuuT?bug_id=4533087

Java 1.5에서 수정되었지만 Sun은 1.4에서 수정할 계획이 없습니다.

문제는 구성시 Thread내부 스레드 테이블의 참조 목록에 a 가 추가된다는 것입니다. start()메서드가 완료 될 때까지 목록에서 제거되지 않습니다 . 해당 참조가있는 한 가비지 수집되지 않습니다.

이것이 java의 인터페이스와 클래스의 차이점에RunnableThread 관한 것 입니다. 더 알고 계시다면 댓글란에 넣어 주시면 게시물 내용에 포함하겠습니다.




