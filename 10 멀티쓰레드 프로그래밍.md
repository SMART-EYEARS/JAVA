# 들어가면서   
> 목표 : 자바의 멀티쓰레드 프로그래밍에 대해 학습하세요.    

# 프로세스와 쓰레드
프로세스는 운영체제로부터 자원을 할당받는 **작업의 단위**이다.         
쓰레드는 프로세스가 할당 받은 자원을 이용하는 **실행 단위**이다.     
      
![01AEC5FD-FDBA-46FE-8DC5-AC667A9AF33E](https://user-images.githubusercontent.com/50267433/105000222-69eee400-5a71-11eb-96ed-e3b4fc81802f.png)       
사진 출처 : [워크맨](https://www.youtube.com/channel/UCwx6n_4OcLgzAGdty0RWCoA)
         
비유 하자면 야구장에서 맥주를 파는 사업을 프로세스라 하고          
본사로부터 맥주를 할당 받아서 판매하는 사람이 쓰레드이다.           
        
![40850_76494_06](https://user-images.githubusercontent.com/50267433/105001975-eb477600-5a73-11eb-85fc-3d9e4f29b563.jpg)       
사진 출처 : [워크맨](https://www.youtube.com/channel/UCwx6n_4OcLgzAGdty0RWCoA)      
     
여기서 맥주 사업 말고 치킨 사업까지 같이 할 경우 이를 멀티 태스킹, 멀티 프로세스라 말하고             
맥주를 할당 받아서 판매하는 사람이 여러명일 경우 이를 멀티 쓰레드라고 말할 수 있다.               
                       
우리가 실행하는 **자바 애플리케이션**은 하나의 프로세스이다.              
애플리케이션 내에서 실행되는 **작업**은 하나의 쓰레드이다.              
그리고 애플리케이션 내에서 작업을 여러개 실행할 경우 이는 멀티 쓰레드가 된다.           
           
# Thread 클래스와 Runnable 인터페이스     
자바에서 쓰레드를 구현할 수 있는 방법은 2가지이다.   

1. Thread 클래스를 상속하여 구현하는 방법        
2. Runnable 인터페이스를 구현하고 Thread에 주입하는 방법     
  
## Thread 클래스    
**Thread 클래스**      
```java
class Thread implements Runnable {
    ...     // 생략
    
    private void init(ThreadGroup g, Runnable target, String name,
                      long stackSize) {
        init(g, target, name, stackSize, null, true);
    }
    
    public Thread(Runnable target) {
        init(null, target, "Thread-" + nextThreadNum(), 0);
    }
        
    /* What will be run. */
    private Runnable target;
        
    @Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }
    
    ...     // 생략
}
```

* `Thread` 클래스는 정의된 클래스로 `Runnable` 인터페이스를 구현한다.                     
* 당연한 얘기이겠지만, Thread와 관련된 변수 및 상수 그리고 메서드를 제공한다.          
* `Runnable` 인터페이스를 구현하기에 `run()` 메서드가 실제로 정의되어 있는 모습이다.      
* 하지만, `run()` 메서드는 Runnable 인터페이스를 구현한 구현체의 `run()`메서드를 실행만 한다.   
* 즉, 개발자가 Runnable 인터페이스의 구현체를 생성자나 `init()`을  통해 주입시켜줘야 한다.     
          
**Thread 클래스를 상속하여 구현하는 방법**
```java
class MyThread extends Thread {
    
    @Override 
    public void run() {
        /* 작업 내용 */
    }      
}
```
앞선 코드에서 보았듯이 Thread 클래스는 의존하는 구현체의 run()을 실행한다.           
그렇기에 상속을 이용한 쓰레드를 구현하고자 한다면               
사용자가 직접 `run()` 메서드를 오바리이딩해서 구현해야한다.                

## Runnable 인터페이스     
**Runnable 인터페이스**         
```java
@FunctionalInterface
public interface Runnable {
    public abstract void run();
}
```
* `Runnable` 인터페이스는 `run()`메서드만을 가지고 있는 함수형 인터페이스다.      
* 클래스에서 `Runnable` 인터페이스를 구현해서 `run()` 정의하고 사용해야한다.     
    
**2. Runnable 인터페이스를 구현하고 Thread에 주입하는 방법**   
```java
class MyRun implements Runnable {
    @Override 
    public void run() {
        /* 작업 내용 */
    }  
}

class Sample {
     public static void main(String[] args) {
         Thread thread = new Thread(new MyRun());
     }
}
```
`Runnable` 인터페이스를 구현했다고 해서 쓰레드가 생성되는 것은 아니다.      
`Runnable` 인터페이스 구현체를 Thread 클래스에 생성자를 통해 주입하고    
`Thread` 클래스를 이용해서 쓰레드를 실행해야 한다.  

```java
class Sample {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> System.out.println("작업 내용"));
    }
}
```
`Runnable` 인터페이스는 함수형 인터페이스이기에 람다식을 사용할 수 있다.       
     
## Thread VS Runnable    
결론부터 말하자면 `Runnable` 인터페이스를 구현하는 것이 주로 선호되는 방법이다.   
   
```java   
class MyThread extends Thread {     // 상속을 추가로 못하게 된다.    
    
    @Override 
    public void run() {
        /* 작업 내용 */
    }      
}
```

Runnable을 구현하면 클래스가 유연해진다.   
자바는 단일 상속만 지원하므로 하나의 클래스만 상속할 수 있다.                         
Thread 클래스를 상속받아 `run()`을 구현한 클래스는 더 이상 상속 받을 수 없다.  

```java
class MyRun implements Runnable {
    @Override 
    public void run() {
        /* 작업 내용 */
    }  
}

class MyRun2 implements Runnable {
    @Override 
    public void run() {
        /* 작업 내용 */
    }  
}

class Sample {
     public static void main(String[] args) {
         Thread thread = new Thread(new MyRun());
         thread = new Thread(new MyRun2());           // 작업 교체  
     }
}
```
또한, Thread 상속받아 구횬하면 수행하려는 작업은 항상 스레드내에만 존재하게된다.       
그러나 Runnable을 구현하는 경우 다양한 Thread 클래스에서 사용할 수 있다.     
그렇기 때문에, 상속에 자유로운 Runnable 인터페이스를 구현하는 것을 선호한다.           

```java
class MyRun implements Runnable {
    @Override 
    public void run() {
        /* 작업 내용 */
    }  
}

class Sample {
     public static void main(String[] args) {
         Thread thread = new Thread(new MyRun());
     }
}
```
또한, 인터페이스로 구현하면 실행 코드와 쓰레드 구현을 명확하게 구분할 수 있다.     


# 쓰레드의 상태
# 쓰레드의 우선순위
# Main 쓰레드
# 쓰레드의 동기화
멀티 쓰레드의 경우,            
여러 쓰레드가 동일한 프로세스 내의 자원을 공유해서 사용하기 때문에              
`Race Condition`과 같이 쓰레드간의 작업에 영향을 줄 수 있다.          
즉, 원래 의도했던 결과가 아닌 **엉뚱하고 치명적인 결과를 불러일으킬 수 있다.**   
      
이러한 문제를 발생시키지 않기 위해서는         
특정 작업을 끝마치기 전까지 다른 쓰레드에 의해 방해받지 않도록 하는 것이 필요하다.        
그래서 도입된 개념이 바로 **임계영역(critical section)** 과 **잠금(lock)** 이다.      
  
![1](https://user-images.githubusercontent.com/50267433/105116605-69585b00-5b0e-11eb-97e9-a2e7bc89eaea.PNG)    
         
공유 데이터를 사용하는 코드 영역을 임계 영역으로 지정해놓고,              
공유 데이터가 가지고 있는 `lock`을 획득한 하나의 쓰레드만 코드를 수행할 수 있게 한다.         
그리고 해당 쓰레드가 임계 영역 내의 모든 코드를 수행하고 벗어나서 lock을 반납해야만       
다른 쓰레드가 반납된 lock을 획득하여 임계 영역의 코드를 수행할 수 있게 된다.    
  
이처럼 **한 쓰레드가 진행 중인 작업을 다른 쓰레드가 간섭하지 못하도록 막는 것**을      
**'쓰레드의 동기화'** 라고 부른다.           
  
## synchronized를 이용한 동기화     
`synchronized` 키워드는 임계 영역을 설정하는데 사용된다.     
`synchronized` 키워드를 사용해 임계 영역을 설정하는 방법은 2가지가 있다.     

1. 메서드 전체를 임계 영역으로 지정 
2. 특정한 영역을 임계 영역으로 지정 
    
```java
// 1. 메서드 전체를 임계 영역으로 지정 
public synchronized void calcSum() {
    // ...
}

// 2. 특정한 영역을 임계 영역으로 지정 
synchronized (객체_참조변수) {
    // ...
}
```

**메서드 전체를 임계 영역으로 지정**   
```java
    public synchronized  void withdraw(int money) {
        if(balance >= money) {
            try {
                Thread.sleep(1000);
            } catch (Exception e){}
            balance -= money;
        }
    }
```
'메서드 전체를 임계 영역으로 지정'하는 방법은       
메서드 앞에 `synchronized` 키워드를 붙이는 것이다.        
`synchronized` 키워드를 붙이면 메서드 전체가 임계 영역으로 설정된다.    
   
쓰레드는 `synchronized 메서드`가 호출된 시점부터      
**해당 메서드가 포함된 객체의 `lock`** 을 얻어 작업을 수행하다가      
메서드가 종료되면 `lock`을 반환한다.        
        
**특정한 영역을 임계 영역으로 지정**            
```java
    public void withdraw(int money) {
        synchronized(this){
            if(balance >= money) {
                try {
                    Thread.sleep(1000);
                } catch (Exception e){}
                balance -= money;
            }    
        }
    }
```
메서드 내의 코드 일부를 블럭`{}`으로 감싸고 이를 임계 영역으로 설정한다.             
이때 **참조변수는 락을 걸고자하는 객체를 참조하는 것이어야 한다.**          

우리는 2가지 방법을 통해 임계 영역을 설정해주었다.   
2가지 방법 모두 lock의 획득과 반납이 모두 자동적으로 이루어진다.   
      
임계 영역은 멀티쓰레드 프로그램의 성능을 좌우하기 때문에 가능하면             
메서드 전체 보다 `synchronized 블럭`으로 임계 영역을 최소화하여 락을 거는 것이 좋다.          
      
**예시**      
은행계좌에서 잔고를 확인하고 임의의 금액을 출금하는 코드를 살펴볼 것이다.      
아래 코드를 보면 잔고가 출금하려는 금액보다 큰 경우에만 출금하도록 정의되어 있다.      
```java
    public void withdraw(int money) {
        if (balance >= money) {                 // 여긴 통과했는데
            try { 
                Thread.sleep(1000); 
            } 
            catch (Exception e) { }
            balance -= money;                   // 여기를 빼앗겼다.   
        }
    }
```
하지만, 실행 결과를 보면 잔고(balance)가 음수인 것을 볼 수 있다.       
그 이유는 한 쓰레드가 if문의 조건식을 통과하고 출금하기 바로 직전에           
다른 쓰레드가 끼어 들어서 출금을 먼저 했기 때문이다.           
즉, 서로 자원을 먼저 사용하려고 뺏으려 경쟁하는 `Race Condiion`이 발생했다.       
           
쉽게 설명하면 두 쓰레드 모두 `if 문`을 통과했지만,             
어느 한 쓰레드가 먼저 출금해 잔고가 마이너스가 된 상황이다.            
그렇기에 잔고를 확인하는 `if 문`과 출금하는 문장은 하나의 임계 영역으로 묶여져야 한다.     

```java
    public synchronized  void withdraw(int money) {
        if(balance >= money) {
            try {
                Thread.sleep(1000);
            } catch (Exception e){}
            balance -= money;
        }
    }
```
```java
    public void withdraw(int money) {
        synchronized(this){
            if(balance >= money) {
                try {
                    Thread.sleep(1000);
                } catch (Exception e){}
                balance -= money;
            }    
        }
    }
```
* 앞서 배웠던 2가지 방법으로 임계 영역을 지정해 동기화를 진행할 수 있다.          

```java
package com.ssafy.algo;

class ThreadEx22 {
    public static void main(String[] args) {
        Runnable r = new RunnableEx22();
        new Thread(r).start();
        new Thread(r).start();
    }

}

class Account {
    private int balance = 1000;

    public int getBalance() {
        return balance;
    }

    public void withdraw(int money) {
        synchronized (this){
            if (balance >= money) {
                try {
                    Thread.sleep(1000);
                }
                catch (Exception e) { }
                balance -= money;
            }
        }
    }
}

class RunnableEx22 implements Runnable{
    Account acc = new Account();

    @Override
    public void run() {
        while (acc.getBalance() > 0){
            int money = (int)(Math.random() * 3 +1) * 100;
            acc.withdraw(money);
            System.out.println("balance:"+acc.getBalance());
        }
    }
}

/* 실행 결과
 * 
 * balance:900
 * balance:800
 * balance:700 
 * balance:400
 * balance:200
 * balance:0
 * balance:0
 */
```
   
## Lock과 Condition을 이용한 동기화    
동기화할 수 있는 방법은 `synchronized` 키워드 외에도          
`java.util.concurrent.locks` 패키지가 제공하는 `lock` 클래스들을 이용하는 방법이 있다.       
  
`synchronized`블럭으로 동기화를 하면 자동적으로 lock이 잠기고 풀리기 때문에 편하다.      
심지어 `synchronized`블럭 내에서 예외가 발생해도 lock은 자동적으로 풀린다.          
하지만, 때로는 같은 메서드 내에서만 `lock`을 걸수 있다는 제약이 불편하기도 하다.    




# RACECONDITION




# 데드락

